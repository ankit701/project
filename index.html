<!--


from django.http import HttpResponse
from django.views import View
from .decorators import oauth_token_required

class DashboardView(View):
    @oauth_token_required
    def get(self, request):
        return HttpResponse('Welcome to the Dashboard!')







from django.views import View
from django.shortcuts import render
from yourapp.decorators import oauth_token_required

class DashboardView(View):
    @oauth_token_required
    def get(self, request):
        # Your view logic here
        return render(request, 'dashboard.html')







from django.http import HttpResponseRedirect
from functools import wraps

def oauth_token_required(view_func):
    @wraps(view_func)
    def _wrapped_view(request, *args, **kwargs):
        if not request.META.get('OAUTH_TOKEN_VALID'):
            # Redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return HttpResponseRedirect(signin_url)
        return view_func(request, *args, **kwargs)

    return _wrapped_view








import requests

def access_example_api(access_token):
    example_api_url = 'http://127.0.0.1:8002/example-api/'  # Replace with the correct URL of your Example API endpoint

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json',
    }

    try:
        response = requests.get(example_api_url, headers=headers)
        response.raise_for_status()  # Raises an HTTPError for bad responses
        return response.json()
    except requests.exceptions.RequestException as e:
        return {'error': f'Request failed: {str(e)}'}

# Example usage:
# Assuming access_token is a valid OAuth 2.0 access token
result = access_example_api(access_token)
print(result)






# example_project/views.py
from rest_framework.permissions import IsAuthenticated
from rest_framework.authentication import OAuth2Authentication
from rest_framework.decorators import authentication_classes, permission_classes

@authentication_classes([OAuth2Authentication])
@permission_classes([IsAuthenticated])
def example_api(request):
    if request.method == 'GET':
        return JsonResponse({"message": "Hello from Example project!"})
    else:
        return JsonResponse({"error": "Invalid request method"}, status=400)







# sso_project/views.py
import requests
from django.http import HttpResponse

def access_example_api(request):
    # Assuming you have the access token, client ID, and client secret
    access_token = 'your_access_token'
    client_id = 'your_client_id'
    client_secret = 'your_client_secret'

    example_url = 'http://127.0.0.1:8001/example-api/'

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json',
    }

    # Assuming a GET request
    response = requests.get(example_url, headers=headers)

    # Process the response as needed
    return HttpResponse(response.text)



# Middleware in dummy1, dummy2, dummy3 projects
class PermissionCheckMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Extract permissions from the access token payload
        access_token = request.GET.get('access_token')
        user_permissions = self.extract_permissions(access_token)

        # Check if the user has the necessary permission for the current view
        if 'can_access_dummy2' in user_permissions:
            # Continue with the original request
            response = self.get_response(request)
            return response
        else:
            # Redirect or handle access denied
            return HttpResponse("Access denied: Insufficient permissions")

    def extract_permissions(self, access_token):
        # Implement logic to extract permissions from the access token payload
        # Replace with actual implementation
        return ['can_access_dummy1', 'can_access_dummy2', 'can_access_dummy3']










from oauth2_provider.models import AccessToken
from django.contrib.auth.models import User

user = User.objects.get(email='user1@example.com')
access_token = AccessToken.objects.create(user=user, scope=' '.join(user.get_all_permissions()))












from django.contrib.auth import get_user_model
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType

User = get_user_model()

# Create a user
user = User.objects.create(email='user1@example.com', password='securepassword')

# Assign a permission (e.g., can_access_dummy2) to the user
content_type = ContentType.objects.get_for_model(User)
permission = Permission.objects.get(content_type=content_type, codename='can_access_dummy2')
user.user_permissions.add(permission)







import requests

class YourDashboardView(View):
    def get(self, request):
        # Assuming you have received the authorization code from the OAuth 2.0 authorization process
        authorization_code = request.GET.get('code')

        # Replace 'your_sso_base_url' with the actual base URL of your SSO project
        sso_base_url = 'http://127.0.0.1:8000/'

        # Construct the URL for the ValidateCodeView in the SSO project
        validate_code_url = f'{sso_base_url}validate-code/'

        # Make a request to the ValidateCodeView with the authorization code
        response = requests.post(validate_code_url, data={'code': authorization_code})

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON to get the access token
            access_token = response.json().get('access_token')
            
            # Now you have the access token and can use it as needed
            # ...

            return HttpResponse(f'Access Token: {access_token}')
        else:
            # Handle the case where the request to validate the code failed
            return HttpResponse('Failed to obtain access token')









from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.authentication import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

class ValidateCodeView(APIView):
    authentication_classes = [OAuth2Authentication]
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        # Check if the user is authenticated
        if request.auth:
            # User is authenticated, proceed with validation logic
            # ...

            # Return the access token
            return Response({'access_token': request.auth.token})

        # Handle unauthenticated request (no valid access token)
        return Response({'error': 'Invalid or missing access token'}, status=401)










import requests

# Assuming you have the SSO project's OAuth 2.0 client credentials
client_id = 'your_sso_client_id'
client_secret = 'your_sso_client_secret'

# Assuming you have the random key obtained during the SSO login process
random_key = 'random_key_obtained_during_login'

# Construct the URL for the SSO's ValidateCodeView
validate_code_url = 'http://127.0.0.1:8000/validate-code/'

# Make a request to the ValidateCodeView with OAuth 2.0 credentials and the random key
response = requests.post(
    validate_code_url,
    data={'random_key': random_key},
    auth=(client_id, client_secret)
)

# Parse the response
if response.status_code == 200:
    access_token = response.json().get('access_token')
    print(f'Success! Access Token: {access_token}')
else:
    error_message = response.json().get('error', 'Unknown error')
    print(f'Error: {error_message}')













# sso_project/views.py
import json
import random
from django.contrib.auth import authenticate
from django.http import JsonResponse, HttpResponseRedirect
from django.views import View
from django.urls import reverse

class SsoLoginView(View):
    def post(self, request):
        # Assuming you have a form or JSON data with username and password
        username = request.POST.get('username')
        password = request.POST.get('password')

        # Authenticate the user
        user = authenticate(request, username=username, password=password)

        if user:
            # Generate a random key for redirection
            random_key = str(random.randint(100000, 999999))

            # Store the random key in a secure way (e.g., database)
            store_random_key(random_key, user)

            # Redirect to the dashboard with the random key
            redirect_url = reverse('dashboard')  # Replace 'dashboard' with your actual URL name
            redirect_url += f'?random_key={random_key}'
            return HttpResponseRedirect(redirect_url)
        else:
            return JsonResponse({'error': 'Invalid credentials'}, status=401)

class ValidateCodeView(View):
    def post(self, request):
        random_key = request.POST.get('random_key')

        # Validate the random key against your secure storage
        user = validate_random_key(random_key)

        if user:
            # Generate and return an access token
            access_token = generate_access_token(user)
            return JsonResponse({'access_token': access_token})
        else:
            return JsonResponse({'error': 'Invalid random key'}, status=401)

def store_random_key(random_key, user):
    # Implement your logic to securely store the random key (e.g., in a database)
    pass

def validate_random_key(random_key):
    # Implement your logic to securely validate the random key and retrieve the associated user
    # Replace this with your actual implementation
    return None  # Return the user if the random key is valid, otherwise return None

def generate_access_token(user):
    # Implement your logic to securely generate an access token based on the user
    # Replace this with your actual implementation
    return 'generated_access_token'















import openpyxl
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from django.http import HttpResponse
from django.db.models import Count

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()

    # Set a password to protect the workbook
    password = "your_password_here"  # Change this to your desired password
    workbook.security.set_workbook_password(password)

    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header1_fill = PatternFill(start_color="000000", end_color="000000", fill_type="solid")  # Black
    header1_font = Font(color="FFFFFF", bold=True)
    header2_date_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_order_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_postclosing_fill = PatternFill(start_color="800080", end_color="800080", fill_type="solid")  # Purple
    header2_font = Font(color="FFFFFF", bold=True)
    header3_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # Light Blue
    header3_font = Font(color="FFFFFF", bold=True)

    # Background color for unused cells
    unused_fill = PatternFill(start_color="FFFFFF", end_color="FFFFFF", fill_type="solid")  # White

    # Border styling
    border = Border(left=Side(border_style='thin', color='000000'),
                   right=Side(border_style='thin', color='000000'),
                   top=Side(border_style='thin', color='000000'),
                   bottom=Side(border_style='thin', color='000000'))

    # Write header1 with color and merge cells
    header1_row = ['Header1']
    start_col = 1
    end_col = len(distinct_statuses) + 2
    cell = worksheet.cell(row=1, column=start_col, value=header1_row[0])
    cell.fill = header1_fill
    cell.font = header1_font
    cell.border = border
    worksheet.merge_cells(start_row=1, start_column=start_col, end_row=1, end_column=end_col)
    cell.alignment = Alignment(horizontal="center")

    # Write header2 with color
    header2_row = ['Date', 'Order', 'Postclosing'] + [''] * len(distinct_statuses)
    for col_num in range(1, len(header2_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = header2_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = header2_postclosing_fill
            cell.font = header2_font  # Set font to bold for 'Postclosing'
            cell.alignment = Alignment(horizontal="center")
        elif 'Date' in cell.value or 'Order' in cell.value:
            cell.fill = header2_date_fill
            cell.font = header2_font  # Set font to bold for 'Date' and 'Order'
            cell.alignment = Alignment(horizontal="center")
        cell.border = border

    # Dynamically merge cells for 'Date' and 'Order'
    worksheet.merge_cells(start_row=2, start_column=1, end_row=3, end_column=1)  # Merge cells for 'Date'
    worksheet.merge_cells(start_row=2, start_column=2, end_row=3, end_column=2)  # Merge cells for 'Order'

    # Write header3 with color
    header3_row = [''] * 2 + list(distinct_statuses)
    for col_num in range(3, len(header3_row) + 1):
        cell = worksheet.cell(row=3, column=col_num)
        cell.value = header3_row[col_num - 1]
        cell.fill = header3_fill
        cell.font = header3_font
        cell.border = border

    # Generate data for each date and status
    date_range = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('created_at', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(created_at=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(created_at=date, status=status).count()
            data_row.append(count)
            # Write data cells with borders
            for col_num in range(1, len(data_row) + 1):
                cell = worksheet.cell(row=worksheet.max_row, column=col_num)
                cell.border = border
                cell.fill = unused_fill if cell.value is None else cell.fill  # Set background color for unused cells

        worksheet.append(data_row)

    # Add a row at the end for totals and set the row to black color
    total_row = ['Total']
    total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date), status=status).count())
    worksheet.append(total_row)
    for cell in worksheet.iter_rows(min_row=worksheet.max_row, max_row=worksheet.max_row, min_col=1, max_col=len(header2_row)):
        for c in cell:
            c.fill = header1_fill
            c.font = header1_font
            c.border = border

    # Set background color for unused cells in the sheet
    for row in worksheet.iter_rows(min_row=worksheet.max_row + 1, max_row=worksheet.max_row + 100, min_col=1, max_col=len(header2_row)):
        for cell in row:
            cell.fill = unused_fill

    file_path = 'F:/work/order_report_{start_date}_to_{end_date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response












import openpyxl
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from django.http import HttpResponse
from django.db.models import Count

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header1_fill = PatternFill(start_color="000000", end_color="000000", fill_type="solid")  # Black
    header1_font = Font(color="FFFFFF", bold=True)
    header2_date_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_order_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_postclosing_fill = PatternFill(start_color="800080", end_color="800080", fill_type="solid")  # Purple
    header2_font = Font(color="FFFFFF", bold=True)
    header3_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # Light Blue
    header3_font = Font(color="FFFFFF", bold=True)

    # Background color for unused cells
    unused_fill = PatternFill(start_color="FFFFFF", end_color="FFFFFF", fill_type="solid")  # White

    # Border styling
    border = Border(left=Side(border_style='thin', color='000000'),
                   right=Side(border_style='thin', color='000000'),
                   top=Side(border_style='thin', color='000000'),
                   bottom=Side(border_style='thin', color='000000'))

    # Write header1 with color and merge cells
    header1_row = ['Header1']
    start_col = 1
    end_col = len(distinct_statuses) + 2
    cell = worksheet.cell(row=1, column=start_col, value=header1_row[0])
    cell.fill = header1_fill
    cell.font = header1_font
    cell.border = border
    worksheet.merge_cells(start_row=1, start_column=start_col, end_row=1, end_column=end_col)
    cell.alignment = Alignment(horizontal="center")

    # Write header2 with color
    header2_row = ['Date', 'Order', 'Postclosing'] + [''] * len(distinct_statuses)
    for col_num in range(1, len(header2_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = header2_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = header2_postclosing_fill
            cell.font = header2_font  # Set font to bold for 'Postclosing'
            cell.alignment = Alignment(horizontal="center")
        elif 'Date' in cell.value or 'Order' in cell.value:
            cell.fill = header2_date_fill
            cell.font = header2_font  # Set font to bold for 'Date' and 'Order'
            cell.alignment = Alignment(horizontal="center")
        cell.border = border

    # Dynamically merge cells for 'Date' and 'Order'
    worksheet.merge_cells(start_row=2, start_column=1, end_row=3, end_column=1)  # Merge cells for 'Date'
    worksheet.merge_cells(start_row=2, start_column=2, end_row=3, end_column=2)  # Merge cells for 'Order'

    # Write header3 with color
    header3_row = [''] * 2 + list(distinct_statuses)
    for col_num in range(3, len(header3_row) + 1):
        cell = worksheet.cell(row=3, column=col_num)
        cell.value = header3_row[col_num - 1]
        cell.fill = header3_fill
        cell.font = header3_font
        cell.border = border

    # Generate data for each date and status
    date_range = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('created_at', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(created_at=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(created_at=date, status=status).count()
            data_row.append(count)
            # Write data cells with borders
            for col_num in range(1, len(data_row) + 1):
                cell = worksheet.cell(row=worksheet.max_row, column=col_num)
                cell.border = border
                cell.fill = unused_fill if cell.value is None else cell.fill  # Set background color for unused cells

        worksheet.append(data_row)

    # Add a row at the end for totals and set the row to black color
    total_row = ['Total']
    total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date), status=status).count())
    worksheet.append(total_row)
    for cell in worksheet.iter_rows(min_row=worksheet.max_row, max_row=worksheet.max_row, min_col=1, max_col=len(header2_row)):
        for c in cell:
            c.fill = header1_fill
            c.font = header1_font
            c.border = border

    # Set background color for unused cells in the sheet
    for row in worksheet.iter_rows(min_row=worksheet.max_row + 1, max_row=worksheet.max_row + 100, min_col=1, max_col=len(header2_row)):
        for cell in row:
            cell.fill = unused_fill

    file_path = 'F:/work/order_report_{start_date}_to_{end_date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'










import openpyxl
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from django.http import HttpResponse
from django.db.models import Count

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header1_fill = PatternFill(start_color="000000", end_color="000000", fill_type="solid")  # Black
    header1_font = Font(color="FFFFFF", bold=True)
    header2_date_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_order_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_postclosing_fill = PatternFill(start_color="800080", end_color="800080", fill_type="solid")  # Purple
    header2_font = Font(color="FFFFFF", bold=True)
    header3_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # Light Blue
    header3_font = Font(color="FFFFFF", bold=True)

    # Border styling
    border = Border(left=Side(border_style='thin', color='000000'),
                   right=Side(border_style='thin', color='000000'),
                   top=Side(border_style='thin', color='000000'),
                   bottom=Side(border_style='thin', color='000000'))

    # Write header1 with color and merge cells
    header1_row = ['Header1']
    start_col = 1
    end_col = len(distinct_statuses) + 2
    cell = worksheet.cell(row=1, column=start_col, value=header1_row[0])
    cell.fill = header1_fill
    cell.font = header1_font
    cell.border = border
    worksheet.merge_cells(start_row=1, start_column=start_col, end_row=1, end_column=end_col)
    cell.alignment = Alignment(horizontal="center")

    # Write header2 with color
    header2_row = ['Date', 'Order', 'Postclosing'] + [''] * len(distinct_statuses)
    for col_num in range(1, len(header2_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = header2_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = header2_postclosing_fill
            cell.font = header2_font  # Set font to bold for 'Postclosing'
            cell.alignment = Alignment(horizontal="center")
        elif 'Date' in cell.value or 'Order' in cell.value:
            cell.fill = header2_date_fill
            cell.font = header2_font  # Set font to bold for 'Date' and 'Order'
            cell.alignment = Alignment(horizontal="center")
        cell.border = border

    # Dynamically merge cells for 'Date' and 'Order'
    worksheet.merge_cells(start_row=2, start_column=1, end_row=3, end_column=1)  # Merge cells for 'Date'
    worksheet.merge_cells(start_row=2, start_column=2, end_row=3, end_column=2)  # Merge cells for 'Order'

    # Write header3 with color
    header3_row = [''] * 2 + list(distinct_statuses)
    for col_num in range(3, len(header3_row) + 1):
        cell = worksheet.cell(row=3, column=col_num)
        cell.value = header3_row[col_num - 1]
        cell.fill = header3_fill
        cell.font = header3_font
        cell.border = border

    # Generate data for each date and status
    date_range = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('created_at', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(created_at=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(created_at=date, status=status).count()
            data_row.append(count)
            # Write data cells with borders
            cell = worksheet.cell(row=worksheet.max_row, column=len(data_row))
            cell.border = border

        worksheet.append(data_row)

    # Add a row at the end for totals and set the row to black color
    total_row = ['Total']
    total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date), status=status).count())
    worksheet.append(total_row)
    for cell in worksheet.iter_rows(min_row=worksheet.max_row, max_row=worksheet.max_row, min_col=1, max_col=len(header2_row)):
        for c in cell:
            c.fill = header1_fill
            c.font = header1_font
            c.border = border

    file_path = 'F:/work/order_report_{start_date}_to_{end_date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response








import openpyxl
from openpyxl.styles import PatternFill, Font, Alignment
from django.http import HttpResponse
from django.db.models import Count

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header1_fill = PatternFill(start_color="000000", end_color="000000", fill_type="solid")  # Black
    header1_font = Font(color="FFFFFF", bold=True)
    header2_date_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_order_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_postclosing_fill = PatternFill(start_color="800080", end_color="800080", fill_type="solid")  # Purple
    header2_font = Font(color="FFFFFF", bold=True)
    header3_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # Light Blue
    header3_font = Font(color="FFFFFF", bold=True)

    # Write header1 with color and merge cells
    header1_row = ['Header1']
    start_col = 1
    end_col = len(distinct_statuses) + 2
    cell = worksheet.cell(row=1, column=start_col, value=header1_row[0])
    cell.fill = header1_fill
    cell.font = header1_font
    worksheet.merge_cells(start_row=1, start_column=start_col, end_row=1, end_column=end_col)
    cell.alignment = Alignment(horizontal="center")

    # Write header2 with color
    header2_row = ['Date', 'Order', 'Postclosing'] + [''] * len(distinct_statuses)
    for col_num in range(1, len(header2_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = header2_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = header2_postclosing_fill
        elif 'Date' in cell.value or 'Order' in cell.value:
            cell.fill = header2_date_fill
        cell.font = header2_font
        cell.alignment = Alignment(horizontal="center")

    # Write header3 with color
    header3_row = [''] * 2 + list(distinct_statuses)
    for col_num in range(1, len(header3_row) + 1):
        cell = worksheet.cell(row=3, column=col_num)
        cell.value = header3_row[col_num - 1]
        cell.fill = header3_fill
        cell.font = header3_font

    worksheet.append([])  # Add an empty row for better visual separation

    # Generate data for each date and status
    date_range = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('created_at', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(created_at=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(created_at=date, status=status).count()
            data_row.append(count)

        worksheet.append(data_row)

    # Add a row at the end for totals
    total_row = ['Total']
    total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date), status=status).count())

    worksheet.append(total_row)

    file_path = 'F:/work/order_report_{start_date}_to_{end_date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response











import openpyxl
from openpyxl.styles import PatternFill, Font, Alignment
from django.http import HttpResponse
from django.db.models import Count

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header1_fill = PatternFill(start_color="000000", end_color="000000", fill_type="solid")  # Black
    header1_font = Font(color="FFFFFF", bold=True)
    header2_date_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_order_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_postclosing_fill = PatternFill(start_color="800080", end_color="800080", fill_type="solid")  # Purple
    header2_font = Font(color="FFFFFF", bold=True)
    header3_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # Light Blue
    header3_font = Font(color="FFFFFF", bold=True)

    # Write header1 with color and merge cells
    header1_row = ['Header1']
    start_col = 1
    end_col = len(distinct_statuses) + 2
    cell = worksheet.cell(row=1, column=start_col, value=header1_row[0])
    cell.fill = header1_fill
    cell.font = header1_font
    worksheet.merge_cells(start_row=1, start_column=start_col, end_row=1, end_column=end_col)
    cell.alignment = Alignment(horizontal="center")

    # Write header2 with color
    header2_row = ['Date', 'Order', 'Postclosing'] + [''] * len(distinct_statuses)
    for col_num in range(1, len(header2_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = header2_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = header2_postclosing_fill
            cell.font = header2_font  # Set font to bold for 'Postclosing'
            cell.alignment = Alignment(horizontal="center")
        elif 'Date' in cell.value or 'Order' in cell.value:
            cell.fill = header2_date_fill
            cell.font = header2_font  # Set font to bold for 'Date' and 'Order'
            cell.alignment = Alignment(horizontal="center")

    # Dynamically merge cells for 'Date' and 'Order'
    worksheet.merge_cells(start_row=2, start_column=1, end_row=3, end_column=1)  # Merge cells for 'Date'
    worksheet.merge_cells(start_row=2, start_column=2, end_row=3, end_column=2)  # Merge cells for 'Order'

    # Write header3 with color
    header3_row = [''] * 2 + list(distinct_statuses)
    for col_num in range(3, len(header3_row) + 1):
        cell = worksheet.cell(row=3, column=col_num)
        cell.value = header3_row[col_num - 1]
        cell.fill = header3_fill
        cell.font = header3_font

    # Generate data for each date and status
    date_range = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('created_at', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(created_at=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(created_at=date, status=status).count()
            data_row.append(count)

        worksheet.append(data_row)

    # Add a row at the end for totals and set the row to black color
    total_row = ['Total']
    total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date), status=status).count())
    worksheet.append(total_row)

    for cell in worksheet.iter_rows(min_row=worksheet.max_row, max_row=worksheet.max_row, min_col=1, max_col=len(header2_row)):
        for c in cell:
            c.fill = header1_fill
            c.font = header1_font

    file_path = 'F:/work/order_report_{start_date}_to_{end_date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response









import openpyxl
from openpyxl.styles import PatternFill, Font, Alignment
from django.http import HttpResponse
from django.db.models import Count

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header1_fill = PatternFill(start_color="000000", end_color="000000", fill_type="solid")  # Black
    header1_font = Font(color="FFFFFF", bold=True)
    header2_date_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_order_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_postclosing_fill = PatternFill(start_color="800080", end_color="800080", fill_type="solid")  # Purple
    header2_font = Font(color="FFFFFF", bold=True)
    header3_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # Light Blue
    header3_font = Font(color="FFFFFF", bold=True)

    # Write header1 with color and merge cells
    header1_row = ['Header1']
    start_col = 1
    end_col = len(distinct_statuses) + 2
    cell = worksheet.cell(row=1, column=start_col, value=header1_row[0])
    cell.fill = header1_fill
    cell.font = header1_font
    worksheet.merge_cells(start_row=1, start_column=start_col, end_row=1, end_column=end_col)
    cell.alignment = Alignment(horizontal="center")

    # Write header2 with color
    header2_row = ['Date', 'Order', 'Postclosing'] + [''] * len(distinct_statuses)
    for col_num in range(1, len(header2_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = header2_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = header2_postclosing_fill
            cell.font = header2_font  # Set font to bold for 'Postclosing'
            start_merge_col = col_num
            cell.alignment = Alignment(horizontal="center")
        elif 'Date' in cell.value or 'Order' in cell.value:
            cell.fill = header2_date_fill
            cell.font = header2_font  # Set font to bold for 'Date' and 'Order'
            cell.alignment = Alignment(horizontal="center")

    # Dynamically merge cells for 'Date' and 'Order'
    worksheet.merge_cells(start_row=2, start_column=1, end_row=3, end_column=1)  # Merge cells for 'Date'
    worksheet.merge_cells(start_row=2, start_column=2, end_row=3, end_column=2)  # Merge cells for 'Order'
    # Merge cells for 'Postclosing'
    worksheet.merge_cells(start_row=2, start_column=start_merge_col, end_row=2, end_column=len(distinct_statuses) + 2)
    # Write header3 with color
    header3_row = [''] * 2 + list(distinct_statuses)
    for col_num in range(3, len(header3_row) + 1):
        cell = worksheet.cell(row=3, column=col_num)
        cell.value = header3_row[col_num - 1]
        cell.fill = header3_fill
        cell.font = header3_font

    # Generate data for each date and status
    date_range = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('created_at', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(created_at=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(created_at=date, status=status).count()
            data_row.append(count)

        worksheet.append(data_row)

    # Add a row at the end for totals
    total_row = ['Total']
    total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date), status=status).count())
    worksheet.append(total_row)

    for cell in worksheet.iter_rows(min_row=worksheet.max_row, max_row=worksheet.max_row, min_col=1, max_col=len(header2_row)-1):
        for c in cell:
            c.fill = header1_fill
            c.font = header1_font

    file_path = 'F:/work/order_report_{start_date}_to_{end_date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response


















import openpyxl
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from django.http import HttpResponse
from django.db.models import Count

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header1_fill = PatternFill(start_color="000000", end_color="000000", fill_type="solid")  # Black
    header1_font = Font(color="FFFFFF", bold=True)
    header2_date_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_order_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Navy Blue
    header2_postclosing_fill = PatternFill(start_color="800080", end_color="800080", fill_type="solid")  # Purple
    header2_font = Font(color="FFFFFF", bold=True)
    header3_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # Light Blue
    header3_font = Font(color="FFFFFF", bold=True)

    # Border styling
    border = Border(left=Side(border_style='thin', color='000000'),
                   right=Side(border_style='thin', color='000000'),
                   top=Side(border_style='thin', color='000000'),
                   bottom=Side(border_style='thin', color='000000'))

    # Write header1 with color and merge cells
    header1_row = ['Header1']
    start_col = 1
    end_col = len(distinct_statuses) + 2
    cell = worksheet.cell(row=1, column=start_col, value=header1_row[0])
    cell.fill = header1_fill
    cell.font = header1_font
    cell.border = border
    worksheet.merge_cells(start_row=1, start_column=start_col, end_row=1, end_column=end_col)
    cell.alignment = Alignment(horizontal="center")

    # Write header2 with color
    header2_row = ['Date', 'Order', 'Postclosing'] + [''] * len(distinct_statuses)
    for col_num in range(1, len(header2_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = header2_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = header2_postclosing_fill
            cell.font = header2_font  # Set font to bold for 'Postclosing'
            cell.alignment = Alignment(horizontal="center")
        elif 'Date' in cell.value or 'Order' in cell.value:
            cell.fill = header2_date_fill
            cell.font = header2_font  # Set font to bold for 'Date' and 'Order'
            cell.alignment = Alignment(horizontal="center")
        cell.border = border

    # Dynamically merge cells for 'Date' and 'Order'
    worksheet.merge_cells(start_row=2, start_column=1, end_row=3, end_column=1)  # Merge cells for 'Date'
    worksheet.merge_cells(start_row=2, start_column=2, end_row=3, end_column=2)  # Merge cells for 'Order'

    # Write header3 with color
    header3_row = [''] * 2 + list(distinct_statuses)
    for col_num in range(3, len(header3_row) + 1):
        cell = worksheet.cell(row=3, column=col_num)
        cell.value = header3_row[col_num - 1]
        cell.fill = header3_fill
        cell.font = header3_font
        cell.border = border

    # Generate data for each date and status
    date_range = Orders.objects.filter(created_at__range=(start_date, end_date)).values_list('created_at', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(created_at=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(created_at=date, status=status).count()
            data_row.append(count)

        worksheet.append(data_row)

    # Add a row at the end for totals and set the row to black color
    total_row = ['Total']
    total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(created_at__range=(start_date, end_date), status=status).count())
    worksheet.append(total_row)
    for cell in worksheet.iter_rows(min_row=worksheet.max_row, max_row=worksheet.max_row, min_col=1, max_col=len(header2_row)):
        for c in cell:
            c.fill = header1_fill
            c.font = header1_font
            c.border = border

    file_path = 'F:/work/order_report_{start_date}_to_{end_date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response












import openpyxl
from openpyxl.styles import PatternFill, Font
from django.http import HttpResponse
from django.db.models import Count
from .models import Orders, AnotherTable

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.GET.get('start_date')
    end_date = request.GET.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(order_creating_date__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Set column width for better readability
    worksheet.column_dimensions['A'].width = 15  # Date
    worksheet.column_dimensions['B'].width = 15  # Total Orders
    for col_num in range(3, len(distinct_statuses) + 3):
        worksheet.column_dimensions[openpyxl.utils.get_column_letter(col_num)].width = 15  # Status columns

    # Apply header styling
    header_fill = PatternFill(start_color="000080", end_color="000080", fill_type="solid")  # Dark blue
    header_font = Font(color="FFFFFF", bold=True)
    date_total_fill = PatternFill(start_color="800000", end_color="800000", fill_type="solid")  # Maroon
    date_total_font = Font(color="FFFFFF", bold=True)
    status_fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")  # Red
    status_font = Font(color="FFFFFF", bold=True)

    # Write headers with colors
    header_row = ['Heading', 'Date', 'Total Orders']
    header_row.extend(distinct_statuses)
    for col_num in range(1, len(header_row) + 1):
        cell = worksheet.cell(row=1, column=col_num)
        cell.value = header_row[col_num - 1]
        cell.fill = header_fill
        cell.font = header_font

    # Write sub-headers with colors
    subheader_row = ['Subheading', '', 'Postclosing']
    subheader_row.extend([''] * len(distinct_statuses))
    for col_num in range(1, len(subheader_row) + 1):
        cell = worksheet.cell(row=2, column=col_num)
        cell.value = subheader_row[col_num - 1]
        if 'Postclosing' in cell.value:
            cell.fill = date_total_fill
            cell.font = date_total_font
        else:
            cell.fill = status_fill
            cell.font = status_font

    worksheet.append([])  # Add an empty row for better visual separation

    # Generate data for each date and status
    date_range = Orders.objects.filter(order_creating_date__range=(start_date, end_date)).values_list('order_creating_date', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(order_creating_date=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(order_creating_date=date, status=status).count()
            data_row.append(count)

        # Count occurrences in AnotherTable based on the order's creation date
        another_table_count = AnotherTable.objects.filter(order__order_creating_date=date).count()
        data_row.append(another_table_count)

        worksheet.append(data_row)

    # Add a row at the end for totals
    total_row = ['Total']
    total_row.append(Orders.objects.filter(order_creating_date__range=(start_date, end_date)).count())
    for status in distinct_statuses:
        total_row.append(Orders.objects.filter(order_creating_date__range=(start_date, end_date), status=status).count())
    total_row.append(AnotherTable.objects.filter(order__order_creating_date__range=(start_date, end_date)).count())
    worksheet.append(total_row)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response










import openpyxl
from openpyxl.styles import PatternFill
from django.http import HttpResponse
from django.db.models import Count
from .models import Orders, AnotherTable

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.GET.get('start_date')
    end_date = request.GET.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(order_creating_date__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Write headers with colors
    header_row = ['Date', 'Total Orders']
    for status in distinct_statuses:
        header_row.append(status)
    header_row.append('Another Table Count')

    # Apply colors to the header row
    fill = PatternFill(start_color="BDD7EE", end_color="BDD7EE", fill_type="solid")
    for col_num in range(1, len(header_row) + 1):
        cell = worksheet.cell(row=1, column=col_num)
        cell.value = header_row[col_num - 1]
        cell.fill = fill

    worksheet.append([])  # Add an empty row for better visual separation

    # Generate data for each date and status
    date_range = Orders.objects.filter(order_creating_date__range=(start_date, end_date)).values_list('order_creating_date', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]

        # Count total orders for the date
        total_orders = Orders.objects.filter(order_creating_date=date).count()
        data_row.append(total_orders)

        # Count orders for each status on that date
        for status in distinct_statuses:
            count = Orders.objects.filter(order_creating_date=date, status=status).count()
            data_row.append(count)

        # Optionally, add counts from another table related to Order model
        another_table_count = AnotherTable.objects.filter(order__order_creating_date=date).count()
        data_row.append(another_table_count)

        worksheet.append(data_row)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response









import openpyxl
from django.http import HttpResponse
from django.db.models import Count
from .models import Orders

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the start_date and end_date)
    start_date = request.GET.get('start_date')
    end_date = request.GET.get('end_date')

    # Get distinct status values
    distinct_statuses = Orders.objects.filter(order_creating_date__range=(start_date, end_date)).values_list('status', flat=True).distinct()

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Write headers
    header_row = ['Date']
    header_row.extend(distinct_statuses)
    worksheet.append(header_row)

    # Generate data for each date and status
    date_range = Orders.objects.filter(order_creating_date__range=(start_date, end_date)).values_list('order_creating_date', flat=True).distinct()

    for date in date_range:
        data_row = [date.strftime('%Y-%m-%d')]
        for status in distinct_statuses:
            count = Orders.objects.filter(order_creating_date=date, status=status).count()
            data_row.append(count)
        worksheet.append(data_row)

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{start_date}_to_{end_date}.xlsx'
    workbook.save(response)

    return response






import os
import openpyxl
from django.http import HttpResponse
from django.db.models import Count, Subquery, OuterRef
from .models import Orders, Recordables, Checks

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the date)
    date = request.GET.get('date')

    # Group orders by status and calculate counts for related records
    status_counts = Orders.objects.filter(order_creating_date=date).values('status').annotate(
        order_count=Count('id'),
        recordables_count=Subquery(
            Recordables.objects.filter(order=OuterRef('id')).values('order').annotate(count=Count('id')).values('count')[:1]
        ),
        checks_count=Subquery(
            Checks.objects.filter(order=OuterRef('id')).values('order').annotate(count=Count('id')).values('count')[:1]
        ),
    )

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Write headers
    worksheet.append(['Status', 'Order Count', 'Recordables Count', 'Checks Count'])

    # Write data
    for status_data in status_counts:
        worksheet.append([status_data['status'], status_data['order_count'], status_data['recordables_count'], status_data['checks_count']])

    # Specify the file path where you want to save the Excel file
    file_path = '/path/to/save/order_report_{date}.xlsx'  # Update this path

    # Save the workbook to the specified file path
    workbook.save(file_path)

    # Create a response with the Excel file (optional if you still want to provide a download link)
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{date}.xlsx'
    workbook.save(response)

    return response


















import openpyxl
from django.http import HttpResponse
from django.db.models import Count, Subquery, OuterRef
from .models import Orders, Recordables, Checks

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the date)
    date = request.GET.get('date')

    # Group orders by status and calculate counts for related records
    status_counts = Orders.objects.filter(order_creating_date=date).values('status').annotate(
        order_count=Count('id'),
        recordables_count=Subquery(
            Recordables.objects.filter(order=OuterRef('id')).values('order').annotate(count=Count('id')).values('count')[:1]
        ),
        checks_count=Subquery(
            Checks.objects.filter(order=OuterRef('id')).values('order').annotate(count=Count('id')).values('count')[:1]
        ),
    )

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Write headers
    worksheet.append(['Status', 'Order Count', 'Recordables Count', 'Checks Count'])

    # Write data
    for status_data in status_counts:
        worksheet.append([status_data['status'], status_data['order_count'], status_data['recordables_count'], status_data['checks_count']])

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{date}.xlsx'
    workbook.save(response)

    return response












import openpyxl
from django.http import HttpResponse
from django.db.models import Count
from .models import Orders, Recordables, Checks

def generate_report(request):
    # Get the parameters from the request (you may adapt this based on how you're passing the date and status)
    date = request.GET.get('date')
    status = request.GET.get('status')

    # Filter orders based on date and status
    orders = Orders.objects.filter(order_creating_date=date, status=status)

    # Count recordables and checks for each order
    orders_data = []
    for order in orders:
        recordables_count = Recordables.objects.filter(order=order).count()
        checks_count = Checks.objects.filter(order=order).count()
        orders_data.append({'order': order, 'recordables_count': recordables_count, 'checks_count': checks_count})

    # Create an Excel workbook and add a worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'Order Report'

    # Write headers
    worksheet.append(['Order ID', 'Recordables Count', 'Checks Count'])

    # Write data
    for data in orders_data:
        worksheet.append([data['order'].id, data['recordables_count'], data['checks_count']])

    # Create a response with the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename=order_report_{date}_{status}.xlsx'
    workbook.save(response)

    return response










# views.py
from django.http import HttpResponse
from django.views import View

class AuthenticatedView1(View):
    def get(self, request):
        if request.META.get('OAUTH_TOKEN_VALID'):
            return HttpResponse('Welcome to Authenticated View 1!')
        else:
            return HttpResponse('Access Denied. Token not valid.')

class AuthenticatedView2(View):
    def get(self, request):
        if request.META.get('OAUTH_TOKEN_VALID'):
            return HttpResponse('Welcome to Authenticated View 2!')
        else:
            return HttpResponse('Access Denied. Token not valid.')









# middleware.py

from django.shortcuts import redirect
import requests

class AccessTokenValidationMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Extract the access token from the request
        access_token = request.GET.get('access_token')

        # Validate the access token
        if not self.validate_access_token(access_token):
            # Token is not valid, redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

        # Set relevant information in request.META
        request.META['OAUTH_USER_ID'] = self.get_user_id(access_token)
        request.META['OAUTH_SCOPES'] = self.get_scopes(access_token)
        request.META['OAUTH_TOKEN_VALID'] = True

        # Continue with the original request
        response = self.get_response(request)

        # Check if the user is logging out
        if 'logout' in request.GET:
            # Reset relevant information
            request.META['OAUTH_USER_ID'] = None
            request.META['OAUTH_SCOPES'] = None
            request.META['OAUTH_TOKEN_VALID'] = False

            # Redirect to the SSO login page after logout
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

        return response

    def validate_access_token(self, access_token):
        # Replace 'token_validation_endpoint', 'client_id', and 'client_secret' with actual values
        token_validation_endpoint = 'http://127.0.0.1:8000/o/introspect/'
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'

        # Make a request to the token validation endpoint
        response = requests.post(
            token_validation_endpoint,
            data={'token': access_token, 'client_id': client_id, 'client_secret': client_secret},
        )

        return response.status_code == 200 and response.json().get('active', False)

    def get_user_id(self, access_token):
        # Implement logic to extract user ID from the token or introspection response
        # Replace with actual implementation
        return 'user123'

    def get_scopes(self, access_token):
        # Implement logic to extract scopes from the token or introspection response
        # Replace with actual implementation
        return ['read', 'write']










from django.urls import path
from django.contrib.auth.views import LogoutView

urlpatterns = [
    # ... (other URL patterns)
    path('logout/', LogoutView.as_view(), name='logout'),
]







class AccessTokenValidationMiddleware:
    # ... (other code)

    def __call__(self, request):
        # ... (existing code)

        # Check if the user is logging out
        if request.path == '/logout/':
            # Perform logout actions
            request.META['OAUTH_TOKEN_VALID'] = False
            request.META.pop('OAUTH_USER_ID', None)
            request.META.pop('OAUTH_SCOPES', None)

            # Redirect to the SSO login page or another appropriate destination
            return redirect('http://127.0.0.1:8000/login/')

        # Continue with the original request
        response = self.get_response(request)
        return response






from django.shortcuts import render
from django.views import View
from .models import Orders
from .serializers import OrdersSerializer

class OrdersListView(View):
    def get(self, request):
        orders = Orders.objects.all()
        serializer = OrdersSerializer(orders, many=True)
        return render(request, 'orders_list.html', {'orders_data': serializer.data})






from django.shortcuts import render
from django.views import View
from .models import CustomUser
from .serializers import CustomUserSerializer

class UserProfileView(View):
    def get(self, request):
        user_id = request.META.get('OAUTH_USER_ID')
        user = CustomUser.objects.get(id=user_id)
        serializer = CustomUserSerializer(user)
        return render(request, 'user_profile.html', {'user_data': serializer.data})





<!DOCTYPE html>
<html>
<head>
    <title>Dashboard</title>
</head>
<body>

<h1>Welcome to the Dashboard!</h1>

<nav>
    <ul>
        <li><a href="{% url 'user_profile' %}">User Profile</a></li>
        <li><a href="{% url 'orders_list' %}">Orders List</a></li>
        <li><a href="{% url 'logout' %}">Log Out</a></li>
    </ul>
</nav>

</body>
</html>








# sso_project/urls.py
from django.urls import path
from .views import initiate_login, SsoLoginView

urlpatterns = [
    path('initiate_login/<str:target_project>/<str:target_subdomain>/', initiate_login, name='initiate_login'),
    path('login/', SsoLoginView.as_view(), name='login'),
]








# sso_project/views.py
from django.shortcuts import redirect

def initiate_login(request, target_project, target_subdomain):
    # Perform any logic needed to initiate the login process
    
    # For demonstration purposes, let's assume a simple check for user authentication
    if request.user.is_authenticated:
        # User is already authenticated, redirect to the target project dashboard
        return redirect(f'http://{target_subdomain}/{target_project}/dashboard/')
    else:
        # User is not authenticated, redirect to the login view of the SSO project
        return redirect(f'http://{target_subdomain}/login/')









# dashboard_project/views.py
from django.shortcuts import redirect
from django.conf import settings
from project_config import PROJECT_CONFIG

def initiate_login_dashboard(request):
    project_name = 'dashboard'
    
    # Retrieve the project configuration dynamically
    project_config = PROJECT_CONFIG.get(project_name, {})
    
    # Construct the initiation URL
    initiate_login_url = f"{project_config.get('base_url', '')}{project_config.get('initiate_login_path', '')}"

    return redirect(initiate_login_url)









# project_config.py
PROJECT_CONFIG = {
    'dashboard': {
        'base_url': 'https://dashboard.mycompany.com/',
        'initiate_login_path': 'initiate_login/dashboard/',
    },
    'holiday': {
        'base_url': 'https://holiday.mycompany.com/',
        'initiate_login_path': 'initiate_login/holiday/',
    },
}









# dashboard_project/views.py
from django.http import HttpResponse
from django.views import View
from django.shortcuts import redirect

class DashboardView(View):
    def get(self, request):
        # Check if the access token is valid
        if not request.META.get('OAUTH_TOKEN_VALID'):
            # Token is not valid, redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

        # Access token is valid, continue processing
        user_id = request.META.get('OAUTH_USER_ID')
        scopes = request.META.get('OAUTH_SCOPES')

        # Your additional logic here using user_id, scopes, etc.

        return HttpResponse(f'Welcome to the Dashboard! User ID: {user_id}, Scopes: {scopes}')






# sso_project/views.py
from django.contrib.auth import authenticate, login
from django.http import JsonResponse, HttpResponseRedirect
from django.views import View
from django.urls import reverse
from oauth2_provider.views import TokenView

class SsoLoginView(View):
    def post(self, request):
        # Assuming you have a form or JSON data with username and password
        username = request.POST.get('username')
        password = request.POST.get('password')

        # Authenticate the user
        user = authenticate(request, username=username, password=password)

        if user:
            # Log in the user
            login(request, user)

            # Issue an OAuth 2.0 access token
            token_response = TokenView.as_view()(request)

            # Extract and include the access token in the redirect URL
            access_token = token_response.data.get('access_token', None)

            if access_token:
                # Redirect to the dashboard project with the access token as a query parameter
                dashboard_url = 'http://127.0.0.1:8001/dashboard/'
                redirect_url = f'{dashboard_url}?access_token={access_token}'
                return HttpResponseRedirect(redirect_url)
            else:
                return JsonResponse({'error': 'Failed to issue access token'}, status=500)

        return JsonResponse({'error': 'Invalid credentials'}, status=401)










import requests
from django.conf import settings

class AccessTokenValidationMiddleware:
    # ... (other methods)

    def get_user_id(self, access_token):
        introspection_endpoint = settings.OAUTH_INTROSPECTION_ENDPOINT
        client_id = settings.OAUTH_CLIENT_ID
        client_secret = settings.OAUTH_CLIENT_SECRET

        response = self.introspect_token(introspection_endpoint, access_token, client_id, client_secret)

        if response.status_code == 200 and response.json().get('active', False):
            # Assuming the user ID is available in the introspection response
            return response.json().get('user_id')

        return None

    def get_scopes(self, access_token):
        introspection_endpoint = settings.OAUTH_INTROSPECTION_ENDPOINT
        client_id = settings.OAUTH_CLIENT_ID
        client_secret = settings.OAUTH_CLIENT_SECRET

        response = self.introspect_token(introspection_endpoint, access_token, client_id, client_secret)

        if response.status_code == 200 and response.json().get('active', False):
            # Assuming the scopes are available in the introspection response
            return response.json().get('scope', '').split()

        return []

    def introspect_token(self, introspection_endpoint, access_token, client_id, client_secret):
        # Make a request to the token introspection endpoint
        response = requests.post(
            introspection_endpoint,
            data={'token': access_token, 'client_id': client_id, 'client_secret': client_secret},
        )

        return response














# dashboard_project/settings.py
MIDDLEWARE = [
    # ...
    'dashboard_project.middleware.AccessTokenValidationMiddleware',
    # ...
]













# dashboard_project/middleware.py
from django.shortcuts import redirect
import requests

class AccessTokenValidationMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Extract the access token from the request
        access_token = request.GET.get('access_token')

        # Validate the access token
        if not self.validate_access_token(access_token):
            # Token is not valid, redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

        # Set relevant information in request.META
        request.META['OAUTH_USER_ID'] = self.get_user_id(access_token)
        request.META['OAUTH_SCOPES'] = self.get_scopes(access_token)
        request.META['OAUTH_TOKEN_VALID'] = True

        # Continue with the original request
        response = self.get_response(request)
        return response

    def validate_access_token(self, access_token):
        # Replace 'token_validation_endpoint', 'client_id', and 'client_secret' with actual values
        token_validation_endpoint = 'http://127.0.0.1:8000/o/introspect/'
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'

        # Make a request to the token validation endpoint
        response = requests.post(
            token_validation_endpoint,
            data={'token': access_token, 'client_id': client_id, 'client_secret': client_secret},
        )

        return response.status_code == 200 and response.json().get('active', False)

    def get_user_id(self, access_token):
        # Implement logic to extract user ID from the token or introspection response
        # Replace with actual implementation
        return 'user123'

    def get_scopes(self, access_token):
        # Implement logic to extract scopes from the token or introspection response
        # Replace with actual implementation
        return ['read', 'write']


















import requests

def validate_access_token(client_id, client_secret, access_token):
    introspection_endpoint = 'http://localhost:8000/oauth2/introspect/'  # Replace with your introspection endpoint

    data = {
        'token': access_token,
        'client_id': client_id,
        'client_secret': client_secret,
    }

    response = requests.post(introspection_endpoint, data=data)

    if response.status_code == 200:
        introspection_data = response.json()
        if introspection_data.get('active', False):
            # Token is valid
            return True
    # Token is not valid
    return False






path('process_selected_orders/', OrderListView.as_view(), name='process_selected_orders'),


========================================================================================================================
from django.shortcuts import render
from django.http import HttpResponse
from reportlab.pdfgen import canvas
from PyPDF2 import PdfMerger
from reportlab.lib.pagesizes import A4
from io import BytesIO

class OrderListView(generics.GenericAPIView):

    def get(self,request):
        return render(request, 'orders.html', {'orders': Orders.objects.all()})
    
    def post(self,request):
        if request.method == 'POST':
            selected_order_ids = request.POST.getlist('selectedOrders')
            if selected_order_ids:
                # Generate separate PDFs for each selected order
                pdf_merger = PdfMerger()

                for order_id in selected_order_ids:
                    order = Orders.objects.get(id=order_id)
                    pdf_content = self.generate_pdf_for_order(order)
                    pdf_merger.append(BytesIO(pdf_content))


                merged_pdf_content = BytesIO()
                pdf_merger.write(merged_pdf_content)

                    # Merge all PDFs into a single PDF
                response = HttpResponse(merged_pdf_content.getvalue(), content_type='application/pdf')
                response['Content-Disposition'] = 'inline; filename=merged_orders.pdf'

                return response

        return render(request, 'orders.html', {'orders': Orders.objects.all()})


    def generate_pdf_for_order(self,order):
        buffer = BytesIO()

        # Create PDF document using ReportLab
        p = canvas.Canvas(buffer, pagesize=A4)

        # Draw the bar chart
        self.draw_bar_chart(p, order)


        p.setFont("Helvetica-Bold", 16)
        p.setFillColorRGB(0, 0, 1)  #Set fill color to blue (RGB)
        
        # Add header
        header_text = 'Order Details'
        text_width = p.stringWidth(header_text, "Helvetica-Bold", 16)
        x_position = (p._pagesize[0] - text_width) / 2  # Center the text horizontally
        p.drawString(x_position, 800, header_text)

        # Set font for other details
        p.setFont("Helvetica", 12)
        p.setFillColorRGB(0, 0, 0)  # Set fill color to black (RGB)

        details_start_y = 760
        p.drawString(100, details_start_y, f'Order ID: {order.id}')
        p.drawString(100, details_start_y-20, f'order number: {order.order_number}')
        p.drawString(100, details_start_y-40, f'tracking number: {order.tracking_number}')
        p.drawString(100, details_start_y-60, f'borrowers first name: {order.borrowers_first_name}')
        p.drawString(100, details_start_y-80, f'check received: {order.check_received}')
        p.drawString(100, details_start_y-100, f'check received amount: {order.check_received_amount}')
        p.drawString(100, details_start_y-120, f'additional comments: {order.additional_comments}')

        # Add more details as needed

        p.showPage()
        p.save()
        buffer.seek(0)
        return buffer.getvalue()
    
    def draw_bar_chart(self, pdf_canvas, order):
        # Draw the bar chart for check_received_amount
        data = {'Check Received Amount': order.check_received_amount}
        self.draw_bar_chart_for_data(pdf_canvas, data)

    def draw_bar_chart_for_data(self, pdf_canvas, data):
        # Set up chart parameters
        chart_x = 100
        chart_y = 500
        bar_width = 30
        max_value = max(data.values())
        scale_factor = 100 / max_value  # Adjust this factor based on your data range

        # Draw bars
        for label, value in data.items():
            bar_height = value * scale_factor
            pdf_canvas.setFillColorRGB(0, 0, 1)  # Set fill color to blue (RGB)
            pdf_canvas.rect(chart_x, chart_y, bar_width, bar_height, fill=1)
            pdf_canvas.setFillColorRGB(0, 0, 0)  # Set fill color back to black (RGB)

            # Add labels below the bars
            pdf_canvas.drawString(chart_x - 5, chart_y - 10, str(label))
            chart_x += 2 * bar_width  # Adjust the horizontal position of the next bar






============================================================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order List</title>
    <style>
        /* Style for the modal */
        #confirmationModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background-color: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            cursor: move;
        }
        #confirmationModal h5 {
            margin: 0;
            padding: 10px;
            background-color: #007bff;
            color: #fff;
            cursor: grab; /* Set cursor to grab when hovering over the modal header */
            user-select: none; /* Disable text selection for the header */
        }
    </style>
</head>
<body>
    <form id="orderForm" action="/process_selected_orders/" method="post" onsubmit="return showConfirmation();" target="_blank">
        <table border="1">
            <thead>
                <tr>
                    <th>Select</th>
                    <th>Order ID</th>
                    <th>order_number</th>
                    <th>tracking_number</th>
                    <th>borrowers_first_name</th>
                    <th>check_received</th>
                    <th>additional_comments</th>
                </tr>
            </thead>
            <tbody>
                {% for order in orders %}
                    <tr>
                        
                        <td><input type="checkbox" name="selectedOrders" value="{{ order.id }}"></td>
                        <td>{{ order.id }}</td>
                        <td>{{ order.order_number }}</td>
                        <td>{{ order.tracking_number }}</td>
                        <td>{{ order.borrowers_first_name }}</td>
                        <td>{{ order.check_received }}</td>
                        <td>{{ order.additional_comments }}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>
        <button type="submit" value="Send">Send</button>
    </form>


    
    <!-- Modal for confirmation -->
    <div id="confirmationModal">
        <h5>Confirmation</h5>
        <p>Do you want to continue?</p>
        <button onclick="proceedWithFormSubmission()">Continue</button>
        <button onclick="cancelFormSubmission()">Back</button>
    </div>


    <script>
        let modal = document.getElementById("confirmationModal");
        let modalHeader = document.querySelector("#confirmationModal h5");
        let isDragging = false;
        let offsetX, offsetY;

        modalHeader.addEventListener("mousedown", startDrag);
        document.addEventListener("mouseup", stopDrag);
        document.addEventListener("mousemove", dragModal);

        function startDrag(e) {
            isDragging = true;
            offsetX = e.clientX - modal.getBoundingClientRect().left;
            offsetY = e.clientY - modal.getBoundingClientRect().top;
            modal.style.transition = "none"; // Disable transition during dragging
        }

        function stopDrag() {
            isDragging = false;
            modal.style.transition = ""; // Enable transition after dragging
        }

        function dragModal(e) {
            if (!isDragging) return;
            modal.style.left = e.clientX - offsetX + "px";
            modal.style.top = e.clientY - offsetY + "px";
        }

        function showConfirmation() {
            // Display the custom confirmation modal
            modal.style.display = "block";
            return false;  // Prevent form submission
        }

        function proceedWithFormSubmission() {
            // Hide the modal and submit the form
            modal.style.display = "none";
            document.getElementById("orderForm").submit();
        }

        function cancelFormSubmission() {
            // Hide the modal and go back to the orders page
            modal.style.display = "none";
            window.location.href = "/orders/";
        }
    </script>



     <script>
        function showConfirmation() {
            // Display the custom confirmation modal
            document.getElementById("confirmationModal").style.display = "block";
            return false;  // Prevent form submission
        }

        function proceedWithFormSubmission() {
            // Hide the modal and submit the form
            document.getElementById("confirmationModal").style.display = "none";
            document.getElementById("orderForm").submit();
        }

        function cancelFormSubmission() {
            // Hide the modal and go back to the orders page
            document.getElementById("confirmationModal").style.display = "none";
            window.location.href = "/process_selected_orders/";
        }
    </script>
 








==================================================================================================================================
from reportlab.lib import colors
from reportlab.graphics.shapes import Drawing
from reportlab.graphics.charts.barcharts import VerticalBarChart

def generate_pdf_for_order(order):
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename=order_{order.id}.pdf'

    # Create PDF document using ReportLab
    p = canvas.Canvas(response)

    # Set color for the header
    header_color = colors.HexColor("#3498db")  # Example: Blue color
    p.setFillColor(header_color)
    p.setFont("Helvetica", 16)

    # Header
    p.drawString(100, 800, f'Order ID: {order.id}')

    # Reset color for the rest of the content
    p.setFillColor(colors.black)
    p.setFont("Helvetica", 12)

    # Content
    p.drawString(100, 780, f'Details: {order.details}')
    
    # Create a simple bar chart using ReportLab
    data = [(f'Item {i}', i * 10) for i in range(1, 6)]  # Example data, replace with your order data
    chart = create_bar_chart(data)
    chart.drawOn(p, 100, 700)  # Adjust the position as needed

    p.showPage()
    p.save()

    return response

def create_bar_chart(data):
    d = Drawing(400, 200)
    bar_chart = VerticalBarChart()
    bar_chart.x = 50
    bar_chart.y = 50
    bar_chart.width = 300
    bar_chart.height = 125
    bar_chart.data = [x[1] for x in data]
    bar_chart.categoryAxis.categoryNames = [x[0] for x in data]

    d.add(bar_chart)

    return d







from reportlab.lib import colors

def generate_pdf_for_order(order):
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename=order_{order.id}.pdf'

    # Create PDF document using ReportLab
    p = canvas.Canvas(response)

    # Set color for the header
    header_color = colors.HexColor("#3498db")  # Example: Blue color
    p.setFillColor(header_color)
    p.setFont("Helvetica", 16)

    # Header
    p.drawString(100, 800, f'Order ID: {order.id}')

    # Reset color for the rest of the content
    p.setFillColor(colors.black)
    p.setFont("Helvetica", 12)

    # Content
    p.drawString(100, 780, f'Details: {order.details}')
    # Add more details as needed

    p.showPage()
    p.save()

    return response






import json
from django.shortcuts import render
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from reportlab.pdfgen import canvas
from PyPDF2 import PdfFileMerger  # Install with: pip install PyPDF2

@csrf_exempt
def process_selected_orders(request):
    if request.method == 'POST':
        selected_order_ids = json.loads(request.POST.get('selectedOrderIds', '[]'))

        if selected_order_ids:
            pdf_merger = PdfFileMerger()

            # Generate separate PDFs for each selected order and add to the merger
            for order_id in selected_order_ids:
                order = YourOrderModel.objects.get(id=order_id)
                pdf = generate_pdf_for_order(order)
                pdf_merger.append(pdf)

            # Create a response with the aggregated PDF
            response = HttpResponse(content_type='application/pdf')
            response['Content-Disposition'] = 'inline; filename=aggregated_orders.pdf'
            pdf_merger.write(response)

            response_data = {'message': 'PDFs generated successfully'}
            return response

    return render(request, 'orders.html', {'orders': YourOrderModel.objects.all()})


def generate_pdf_for_order(order):
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename=order_{order.id}.pdf'

    # Create PDF document using ReportLab
    p = canvas.Canvas(response)
    p.drawString(100, 800, f'Order ID: {order.id}')
    p.drawString(100, 780, f'Details: {order.details}')
    # Add more details as needed

    p.showPage()
    p.save()

    return response






import json
from django.shortcuts import render
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from reportlab.pdfgen import canvas
from PyPDF2 import PdfFileMerger  # Install with: pip install PyPDF2

@csrf_exempt
def process_selected_orders(request):
    if request.method == 'POST':
        selected_order_ids = json.loads(request.POST.get('selectedOrderIds', '[]'))

        if selected_order_ids:
            pdf_merger = PdfFileMerger()

            # Generate separate PDFs for each selected order and add to the merger
            for order_id in selected_order_ids:
                order = YourOrderModel.objects.get(id=order_id)
                pdf = generate_pdf_for_order(order)
                pdf_merger.append(pdf)

            # Create a response with the aggregated PDF
            response = HttpResponse(content_type='application/pdf')
            response['Content-Disposition'] = 'attachment; filename=aggregated_orders.pdf'
            pdf_merger.write(response)

            response_data = {'message': 'PDFs generated successfully'}
            return response

    return render(request, 'orders.html', {'orders': YourOrderModel.objects.all()})


def generate_pdf_for_order(order):
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename=order_{order.id}.pdf'

    # Create PDF document using ReportLab
    p = canvas.Canvas(response)
    p.drawString(100, 800, f'Order ID: {order.id}')
    p.drawString(100, 780, f'Details: {order.details}')
    # Add more details as needed

    p.showPage()
    p.save()

    return response





Certainly! To achieve this functionality in Django Rest Framework, you'll need to create an HTML page with a table displaying orders, checkboxes for each order, and a "Send" button. Here's a simplified example:

Create an HTML page (e.g., orders.html):
html
Copy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order List</title>
</head>
<body>
    <form id="orderForm">
        <table border="1">
            <thead>
                <tr>
                    <th>Order ID</th>
                    <th>Order Details</th>
                    <th>Select</th>
                </tr>
            </thead>
            <tbody>
                {% for order in orders %}
                    <tr>
                        <td>{{ order.id }}</td>
                        <td>{{ order.details }}</td>
                        <td><input type="checkbox" name="selectedOrders" value="{{ order.id }}"></td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>
        <button type="button" onclick="sendSelectedOrders()">Send</button>
    </form>

    <script>
        function sendSelectedOrders() {
            const selectedOrderIds = Array.from(document.querySelectorAll('input[name="selectedOrders"]:checked'))
                                       .map(checkbox => checkbox.value);

            if (selectedOrderIds.length > 0) {
                const formData = new FormData();
                formData.append('selectedOrderIds', JSON.stringify(selectedOrderIds));

                fetch('/path/to/your/view/', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    // Handle the response, e.g., display a success message
                    console.log(data);
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            } else {
                alert('Please select at least one order.');
            }
        }
    </script>
</body>
</html>
Create a Django view in views.py to handle the form submission:
python
Copy code
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt  # Add this decorator if you encounter CSRF token issues
def process_selected_orders(request):
    if request.method == 'POST':
        selected_order_ids = json.loads(request.POST.get('selectedOrderIds', '[]'))
        
        # Now you have the selected order IDs, you can generate PDFs and perform other actions
        # Replace this part with your logic for generating PDFs and any other processing
        
        response_data = {'message': 'Orders processed successfully'}
        return JsonResponse(response_data)

    return render(request, 'orders.html', {'orders': YourOrderModel.objects.all()})
Ensure to replace YourOrderModel with the actual model you are using to store orders.

Include the URL mapping in your urls.py:
python
Copy code
from django.urls import path
from .views import process_selected_orders

urlpatterns = [
    # Your other URLs...
    path('process_selected_orders/', process_selected_orders, name='process_selected_orders'),
]
Now, when you select orders and click the "Send" button, it will send the selected order IDs to the process_selected_orders view, where you can implement the logic to generate separate PDFs for each order.




User
Now you have the selected order IDs, you can generate PDFs and perform other actions
        # Replace this part with your logic for generating PDFs and any other processing
        

Write the code for this too and implement in the above code and give the code as a whole 

ChatGPT
Certainly! To generate PDFs for the selected order IDs, you can use a library like ReportLab for creating PDF documents. Install it using:

bash
Copy code
pip install reportlab
Now, integrate the PDF generation logic into your Django view. Below is the updated code:

python
Copy code
import json
from django.shortcuts import render
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from reportlab.pdfgen import canvas

@csrf_exempt
def process_selected_orders(request):
    if request.method == 'POST':
        selected_order_ids = json.loads(request.POST.get('selectedOrderIds', '[]'))

        if selected_order_ids:
            # Generate separate PDFs for each selected order
            for order_id in selected_order_ids:
                order = YourOrderModel.objects.get(id=order_id)
                generate_pdf_for_order(order)

            response_data = {'message': 'PDFs generated successfully'}
            return JsonResponse(response_data)

    return render(request, 'orders.html', {'orders': YourOrderModel.objects.all()})


def generate_pdf_for_order(order):
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename=order_{order.id}.pdf'

    # Create PDF document using ReportLab
    p = canvas.Canvas(response)
    p.drawString(100, 800, f'Order ID: {order.id}')
    p.drawString(100, 780, f'Details: {order.details}')
    # Add more details as needed

    p.showPage()
    p.save()

    return response
In this example, generate_pdf_for_order is a function that creates a PDF for a given order using ReportLab. The HttpResponse with the appropriate content type and disposition is used to return the generated PDF as a response.

Make sure to replace
















------------------------------------------------------------------------------------------------------------------------------------------------------------------
import pandas as pd
from django.db import transaction
from rest_framework.response import Response
from rest_framework import status
from rest_framework.views import APIView
from .models import Orders, Employee

class BulkUploadView(APIView):
    def create_order_instance(self, record_data, employee_id):
        try:
            employee_instance = Employee.objects.get(employee_id=employee_id)
        except Employee.DoesNotExist:
            raise ValueError(f'Employee with ID {employee_id} not found.')

        # Set the employee instance to the 'employee' field
        record_data['employee'] = employee_instance

        # Manually set 'status' field
        record_data['status'] = 'manifest_pending'

        # Check for duplicates before saving
        if Orders.objects.filter(order_number=record_data['order_number']).exists():
            return None, record_data['order_number']  # Duplicate order

        return Orders.objects.create(**record_data), None

    def post(self, request, *args, **kwargs):
        file = request.FILES.get('file')

        if file is None or not file.name.endswith(('.xls', '.xlsx')):
            return Response({'error': 'Please upload a valid Excel file.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            df = pd.read_excel(file)

            # Use a list to store duplicate orders
            duplicate_orders = []

            with transaction.atomic():
                for record_data in df.to_dict(orient='records'):
                    employee_id = 'NSPL0904'  # Replace 'ABC123' with the actual employee_id

                    order_instance, duplicate_order_number = self.create_order_instance(record_data, employee_id)

                    if duplicate_order_number:
                        duplicate_orders.append(duplicate_order_number)

            if duplicate_orders:
                return Response({'warning': f'Duplicate orders found: {", ".join(duplicate_orders)}'},
                                status=status.HTTP_200_OK)

            return Response({'success': 'Data uploaded successfully.'}, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)







---------------------------------------------------------------------------------------------------------------------------------------------------------
# serializers.py
from rest_framework import serializers

class SignupSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True, required=False)  # Password is optional in the first step




++++++++++++++++++++++++++++++++++
# views.py
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from .serializers import SignupSerializer
from django.contrib.auth.models import User

class SignupView(APIView):
    def post(self, request, *args, **kwargs):
        serializer = SignupSerializer(data=request.data)
        if serializer.is_valid():
            email = serializer.validated_data['email']
            password = serializer.validated_data['password']

            # Check if the email already exists
            if User.objects.filter(email=email).exists():
                return Response({'error': 'Email already exists'}, status=status.HTTP_400_BAD_REQUEST)

            # Proceed with the signup process
            user = User.objects.create_user(email=email, password=password)

            return Response({'message': 'Signup successful'}, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)





---------------------

from oauth2_provider.models import RefreshToken

# Assuming `refresh_token` is the refresh token you want to check
try:
    # Try to get the corresponding refresh token
    refresh_token_instance = RefreshToken.objects.get(token=refresh_token)
    
    # Check if the refresh token is expired
    if refresh_token_instance.access_token.expires < timezone.now():
        # Expired, re-authenticate the user and obtain new tokens
        # Redirect the user to the authentication page or initiate a new authentication process
        # Request new access and refresh tokens after successful authentication
        # ...

    # Use the current refresh token for the refresh operation
    # ...
except RefreshToken.DoesNotExist:
    # The refresh token doesn't exist; handle accordingly
    # ...




# myapp/views.py

from rest_framework import status
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from myapp.serializers import UserSerializer  # Import your UserSerializer
from django.http import JsonResponse

@api_view(['POST'])
@permission_classes([AllowAny])
def signup(request):
    serializer = UserSerializer(data=request.data)

    if serializer.is_valid():
        user, access_token, refresh_token = serializer.save()

        # You can customize the response based on your needs
        response_data = {
            'access_token': access_token.token,
            'refresh_token': refresh_token.token,
            'user_id': user.id,
            'message': 'User signup and token creation successful'
        }

        return JsonResponse(response_data, status=status.HTTP_201_CREATED)
    else:
        return JsonResponse({'error': 'Invalid data'}, status=status.HTTP_400_BAD_REQUEST)








# myapp/serializers.py

from rest_framework import serializers
from django.contrib.auth.models import User
from oauth2_provider.models import Application, AccessToken, RefreshToken

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'password']

    def create(self, validated_data):
        # Create a new user
        user = User.objects.create_user(**validated_data)

        # Replace 'your_client_id' and 'your_client_secret' with the actual client credentials
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'

        try:
            # Try to find an existing application with the given client credentials
            application = Application.objects.get(client_id=client_id, client_secret=client_secret)
        except Application.DoesNotExist:
            # Handle the case where the application does not exist
            # You may raise an exception, log a message, or handle it based on your requirements
            raise Exception('Application not found with the provided client credentials')

        # Create an access token for the user with the existing application
        access_token = AccessToken.objects.create(
            user=user,
            application=application,
            scope='read write',
        )

        # Create a refresh token for the user with the existing application
        refresh_token = RefreshToken.objects.create(
            user=user,
            application=application,
        )

        return user, access_token, refresh_token











# myapp/views.py

from rest_framework import status
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from oauth2_provider.models import Application, AccessToken, RefreshToken
from django.contrib.auth.models import User
from django.http import JsonResponse

@api_view(['POST'])
@permission_classes([AllowAny])
def signup(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' with your actual client ID
    client_id = 'your_client_id'
    
    # Your signup logic here...
    # For example, create a new user instance and save it to the database
    user = User.objects.create(username=request.data.get('username'), password=request.data.get('password'))

    # Create an OAuth2 Application (client) for the user
    application, _ = Application.objects.get_or_create(
        user=user,
        authorization_grant_type='password',
        client_type='confidential',
        name=f"{user.username}'s Application",
        client_id=client_id,
    )

    # Create an access token for the user
    access_token = AccessToken.objects.create(
        user=user,
        application=application,
        scope='read write',
    )

    # Create a refresh token for the user
    refresh_token = RefreshToken.objects.create(
        user=user,
        application=application,
    )

    return JsonResponse({
        'access_token': access_token.token,
        'refresh_token': refresh_token.token,
        'user_id': user.id,
        'message': 'User signup and token creation successful'
    })

@api_view(['POST'])
@permission_classes([AllowAny])
def signin(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' with your actual client ID
    client_id = 'your_client_id'
    access_token = request.data.get('access_token')

    # Verify the access token
    try:
        existing_token = AccessToken.objects.get(token=access_token, application__client_id=client_id)
        
        # If a valid token exists, return user details
        return JsonResponse({
            'user_id': existing_token.user.id,
            'message': 'User authenticated with existing token'
        })
    except AccessToken.DoesNotExist:
        # Token does not exist or is invalid
        return JsonResponse({'error': 'Invalid access token'}, status=status.HTTP_401_UNAUTHORIZED)





##################№#######)##############
# myapp/urls.py

from django.urls import path
from .views import refresh_token, protected_view

urlpatterns = [
    path('refresh-token/', refresh_token, name='refresh_token'),
    path('protected-view/', protected_view, name='protected_view'),
    # Add other URLs as needed
]


######################################

# myapp/views.py

import requests
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from django.http import JsonResponse

@api_view(['POST'])
@permission_classes([AllowAny])
def refresh_token(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' and 'your_client_secret' with your actual client credentials
    client_id = 'your_client_id'
    client_secret = 'your_client_secret'
    refresh_token = request.data.get('refresh_token')

    data = {
        'grant_type': 'refresh_token',
        'refresh_token': refresh_token,
        'client_id': client_id,
        'client_secret': client_secret,
    }

    # Make a POST request to the OAuth2 token refresh endpoint
    response = requests.post('http://localhost:8000/oauth2/token/', data=data)

    if response.status_code == 200:
        # Successfully refreshed, parse the response
        token_data = response.json()
        access_token = token_data.get('access_token')
        refresh_token = token_data.get('refresh_token')

        # Your logic after successful token refresh
        return JsonResponse({'access_token': access_token, 'refresh_token': refresh_token, 'message': 'Token refresh successful'})
    else:
        # Token refresh failed
        return JsonResponse({'error': 'Token refresh failed'}, status=response.status_code)



---_--------------------------777777777-------

path('oauth2/', include('oauth2_provider.urls', namespace='oauth2_provider')),
]


AUTHENTICATION_CLASSES = [
    'oauth2_provider.contrib.rest_framework.OAuth2Authentication',
    # ... (other authentication classes, if needed)
]

==============--------------------======================================--------------------------====================----------======
_________++++++++++++++++++++++++++++++++++++++++++______________________++++++++++++++++++++++++++++++++++++++___________________+++++

To achieve this, you can implement a single sign-on (SSO) approach between the two projects. One way to implement SSO is by using OAuth 2.0. In this scenario, the first project (http://127.0.0.1:8000/signin/) acts as an OAuth 2.0 Authorization Server, and the second project (http://127.0.0.1:8001/dashboard/) acts as the OAuth 2.0 Resource Server.

Here are the high-level steps you can follow:

Configure OAuth 2.0 in the Sign-In Project (Authorization Server):

Configure the Django OAuth Toolkit or another OAuth 2.0 provider in your sign-in project.
Set up client credentials for the second project (http://127.0.0.1:8001/dashboard/) in the Authorization Server.
Redirect from the Dashboard Project to the Sign-In Project for Authentication:

When a user tries to access the dashboard in the second project without being authenticated, redirect them to the authorization URL of the first project for authentication.
User Authentication in the Sign-In Project:

In the first project, handle the user's authentication and issue an access token upon successful authentication.
Redirect Back to the Dashboard Project with the Access Token:

After authentication in the first project, redirect the user back to the dashboard in the second project with the access token.
Access Dashboard Resources with the Access Token:

In the second project, validate the access token received from the first project and grant access to protected resources.
Below is a simplified example using OAuth 2.0 and Django OAuth Toolkit. Note that this is a basic illustration, and you may need to adjust it based on your specific requirements and OAuth 2.0 provider.

python
Copy code
# Sign-In Project (http://127.0.0.1:8000/signin/)

# views.py
from django.shortcuts import redirect
from django.urls import reverse
from django.http import JsonResponse
from oauth2_provider.models import Application, AccessToken
from django.contrib.auth import authenticate, login

def signin(request):
    # Handle user authentication
    # Issue access token upon successful authentication
    # ...

    # Redirect back to the dashboard with the access token
    dashboard_url = 'http://127.0.0.1:8001/dashboard/'
    return redirect(f'{dashboard_url}?access_token={access_token}')

# Dashboard Project (http://127.0.0.1:8001/dashboard/)

# views.py
from django.http import HttpResponse
from django.views import View

class DashboardView(View):
    def get(self, request):
        access_token = request.GET.get('access_token')

        # Validate the access token with the Authorization Server
        if self.validate_access_token(access_token):
            return HttpResponse('Welcome to the Dashboard!')
        else:
            # Redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

    def validate_access_token(self, access_token):
        # Use OAuth 2.0 token validation logic here
        # ...

        return True  # Placeholder; replace with actual validation logic
In this example, the signin view in the sign-in project handles user authentication and redirects back to the dashboard project with the access token as a query parameter. The DashboardView in the dashboard project validates the access token and either grants access to the dashboard or redirects to the sign-in project for authentication.

Please note that this is a simplified example, and you'll need to implement proper OAuth 2.0 flows, handle security considerations, and integrate the Django OAuth Toolkit or another OAuth 2.0 provider according to your project's needs.

User
what will be the code for this?

def validate_access_token(self, access_token):
ChatGPT
To validate an access token, you typically need to make a request to the OAuth 2.0 Authorization Server's token validation endpoint. The OAuth 2.0 provider (in your case, Django OAuth Toolkit) should provide an endpoint for token validation.

Here's an example of how you might implement the validate_access_token method using requests to validate the access token with Django OAuth Toolkit:

python
Copy code
# Dashboard Project (http://127.0.0.1:8001/dashboard/)

# views.py
from django.http import HttpResponse
from django.views import View
import requests

class DashboardView(View):
    def get(self, request):
        access_token = request.GET.get('access_token')

        # Validate the access token with the Authorization Server
        if self.validate_access_token(access_token):
            return HttpResponse('Welcome to the Dashboard!')
        else:
            # Redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

    def validate_access_token(self, access_token):
        # Replace 'your_token_validation_endpoint' with the actual token validation endpoint provided by your OAuth 2.0 provider
        token_validation_endpoint = 'http://127.0.0.1:8000/o/introspect/'

        # Replace 'your_client_id' and 'your_client_secret' with the actual client credentials for the Dashboard project
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'

        # Make a request to the token validation endpoint
        response = requests.post(
            token_validation_endpoint,
            data={'token': access_token, 'client_id': client_id, 'client_secret': client_secret},
        )

        if response.status_code == 200:
            # Token is valid
            return True
        else:
            # Token is invalid
            return False
Please note that the exact endpoint and parameters for token validation may vary depending on the OAuth 2.0 provider you are using. Make sure to consult the documentation of your OAuth 2.0 provider (Django OAuth Toolkit in this case) for details on token validation.

Also, ensure that you handle errors, such as network issues or unexpected responses, gracefully in a production setting. The example above assumes a successful response status code of 200 for simplicity.

User
# Replace 'your_token_validation_endpoint' with the actual token validation endpoint provided by your OAuth 2.0 provider
        token_validation_endpoint = 'http://127.0.0.1:8000/o/introspect/'

which url should I give here?
ChatGPT
In Django OAuth Toolkit, the introspect endpoint is used to validate access tokens. The default introspect endpoint URL is usually /o/introspect/ relative to the base URL of your OAuth 2.0 provider.

However, the actual URL may vary depending on your Django project's configuration. You can check your Django project's urls.py to find the correct endpoint. If you haven't customized it, the default introspect endpoint is often available at /o/introspect/.

Here's an example of what the urls.py might look like in your Django OAuth Toolkit-enabled project:

python
Copy code
# Your Django OAuth Toolkit-enabled project's urls.py

from django.urls import path
from oauth2_provider.views.introspect import IntrospectTokenView

urlpatterns = [
    # ... other URL patterns ...

    # Introspect endpoint
    path('o/introspect/', IntrospectTokenView.as_view(), name='introspect-token'),

    # ... other URL patterns ...
]
In this case, the introspect endpoint is available at /o/introspect/.

If you have customized the URL pattern or are using a different OAuth 2.0 provider, refer to the provider's documentation or check the relevant configuration in your Django project. The introspect endpoint is specifically designed for token introspection and validation.

User
generally what is the the actual token validation endpoint provided by your OAuth 2.0 provider?
ChatGPT
The token validation endpoint in OAuth 2.0 is specified by the OAuth 2.0 Token Introspection standard. The endpoint is used to check the validity of an access token, and the response from this endpoint provides information about the token, such as its validity, scope, and associated user.

The typical URL for the token validation endpoint is /oauth2/introspect/ or /o/introspect/. However, the exact endpoint URL can vary based on the OAuth 2.0 provider you are using, as different providers may have different conventions.

For example:

Django OAuth Toolkit: /o/introspect/
Keycloak: /protocol/openid-connect/token/introspect
Auth0: /oauth/token/introspect
Okta: /oauth2/v1/introspect
It's essential to consult the documentation of your specific OAuth 2.0 provider to determine the correct token validation endpoint. The provider's documentation should specify the endpoint's URL and any additional parameters required for the introspection request.

If you are using Django OAuth Toolkit, the default introspect endpoint can often be found in your Django project's urls.py. If you have customized the endpoint, refer to your project's configuration.

In any case, the token validation endpoint is an essential part of OAuth 2.0, and understanding the specifics for your chosen provider is crucial for proper integration.

User
will this 
signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url) 
work?
ChatGPT
The line of code you provided:

python
Copy code
signin_url = 'http://127.0.0.1:8000/signin/'
return redirect(signin_url)
will redirect the user to the specified signin_url. However, there are a couple of considerations:

Cross-Origin Issues: If your projects are running on different ports (e.g., one on 8000 and the other on 8001), you might encounter cross-origin issues. Browsers may restrict redirects across different origins for security reasons. In a production environment, it's common to use a common domain or implement Cross-Origin Resource Sharing (CORS) to handle these scenarios.

Relative URLs: Instead of hardcoding the base URL, you might want to make the redirection more flexible by using relative URLs. Django provides the reverse function for this purpose. For example:

python
Copy code
from django.urls import reverse

signin_url = reverse('signin')  # 'signin' is the name of the URL pattern for your signin view
return redirect(signin_url)
This way, if you change the URL pattern for the signin view, you won't need to update the URL in multiple places.

OAuth Redirect URI: If you're integrating with OAuth 2.0, be sure that the redirect URI used for the authentication request (during the initial redirect to the sign-in project) is correctly registered with your OAuth 2.0 provider. The provider will redirect the user back to this URI after successful authentication.

Ensure that the considerations above align with your specific project setup and requirements. If you encounter issues, provide more details about your project structure, URLs, and any error messages you're encountering for more targeted assistance.

User
OAuth Redirect URI: If you're integrating with OAuth 2.0, be sure that the redirect URI used for the authentication request (during the initial redirect to the sign-in project) is correctly registered with your OAuth 2.0 provider. The provider will redirect the user back to this URI after successful authentication.

so in the demo project what should i write for redirect uri?
ChatGPT
The redirect URI in your demo project (the OAuth 2.0 client or relying party) should be set to the URL where you expect the OAuth 2.0 provider to redirect the user after successful authentication. This URL is often referred to as the OAuth 2.0 Redirect URI or Callback URL.

Assuming your demo project is running at http://127.0.0.1:8001/, you might set the redirect URI to something like:

bash
Copy code
http://127.0.0.1:8001/oauth2/callback/
Here are the steps to set up the redirect URI:

In Your Demo Project:

Determine the URL where you want the user to be redirected after successful authentication. This could be a specific endpoint, like /dashboard/ or /oauth2/callback/.
Register this URL as the redirect URI in your demo project.
In Your OAuth 2.0 Provider (Sign-In Project):

When initiating the OAuth 2.0 authentication request (e.g., during the initial redirect from the demo project to the sign-in project), include the registered redirect URI in the request.
For example, if you're using Django OAuth Toolkit in the sign-in project, you might have a configuration like this:

python
Copy code
# settings.py in the sign-in project
OAUTH2_PROVIDER = {
    'SCOPES': {'read': 'Read scope'},
    'ALLOWED_REDIRECT_URI_SCHEMES': ['http', 'https'],
}
Ensure that the redirect URI used in the OAuth 2.0 authentication request matches the one registered with your OAuth 2.0 provider. If they don't match, the provider may reject the request for security reasons.

Remember that the exact steps and configurations may vary depending on the OAuth 2.0 provider you are using, so refer to the provider's documentation for detailed instructions.







++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===================================================================================================================================
from django.urls import path
from .views import SignInView, ProtectedView

urlpatterns = [
    path('signin/', SignInView.as_view(), name='signin'),
    path('protected-view/', ProtectedView.as_view(), name='protected_view'),
    # Add other URLs as needed
]



# myapp/views.py

import requests
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.decorators import permission_classes, authentication_classes
from rest_framework.permissions import AllowAny
from rest_framework.authentication import SessionAuthentication, BasicAuthentication
from django.contrib.auth import authenticate, login
from django.http import JsonResponse
from oauth2_provider.models import AccessToken

class SignInView(APIView):
    permission_classes = [AllowAny]
    authentication_classes = [SessionAuthentication, BasicAuthentication]

    def post(self, request):
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'
        username = request.data.get('username')
        password = request.data.get('password')

        existing_token = AccessToken.objects.filter(user__username=username).first()

        if existing_token and existing_token.is_valid():
            return JsonResponse({'access_token': existing_token.token, 'refresh_token': existing_token.user.refresh_token.token, 'user_id': existing_token.user.id, 'message': 'User already authenticated'})
        elif existing_token and existing_token.is_expired():
            new_access_token, new_refresh_token, user_id = self.refresh_access_token(existing_token.user.refresh_token.token, client_id, client_secret)

            user = authenticate(request, username=username, password=password)
            if user is not None:
                login(request, user)
                return JsonResponse({'access_token': new_access_token, 'refresh_token': new_refresh_token, 'user_id': user.id, 'message': 'Token refresh successful'})
        
        data = {
            'grant_type': 'password',
            'username': username,
            'password': password,
            'client_id': client_id,
            'client_secret': client_secret,
        }

        response = requests.post('http://localhost:8000/oauth2/token/', data=data)

        if response.status_code == 200:
            token_data = response.json()
            access_token = token_data.get('access_token')
            refresh_token = token_data.get('refresh_token')

            user = authenticate(request, username=username, password=password)
            if user is not None:
                login(request, user)
                return JsonResponse({'access_token': access_token, 'refresh_token': refresh_token, 'user_id': user.id, 'message': 'Sign-in successful'})
        else:
            return JsonResponse({'error': 'Invalid credentials'}, status=response.status_code)

    def refresh_access_token(self, refresh_token, client_id, client_secret):
        data = {
            'grant_type': 'refresh_token',
            'refresh_token': refresh_token,
            'client_id': client_id,
            'client_secret': client_secret,
        }

        response = requests.post('http://localhost:8000/oauth2/token/', data=data)

        if response.status_code == 200:
            token_data = response.json()
            new_access_token = token_data.get('access_token')
            new_refresh_token = token_data.get('refresh_token')
            user_id = token_data.get('user_id')  # Assuming the server provides the user ID in the response
            return new_access_token, new_refresh_token, user_id
        else:
            return None, None, None


class ProtectedView(APIView):
    authentication_classes = [SessionAuthentication, BasicAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        return Response({'message': f'Hello, {user.username}! This is a protected view.'})

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===========================================================================================================================

'oauth2_provider.middleware.OAuth2TokenMiddleware',


OAUTH2_PROVIDER = {
    'SCOPES': {'read': 'Read scope', 'write': 'Write scope'},
}

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
    ],
    # ... other settings
}
-------------------------------------------------------------------------------------------------------------------------------
from django.urls import path
from .views import *

urlpatterns = [
    path('signin/', signin, name='signin'),
    path('protected_view/', protected_view, name='protected_view'),
]


=================================================================================================================================

from rest_framework import status
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes,authentication_classes
from rest_framework.permissions import AllowAny
from django.contrib.auth import authenticate, login
from django.http import JsonResponse
import requests
from oauth2_provider.models import AccessToken
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

@api_view(['POST'])
@permission_classes([AllowAny])
def signin(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' and 'your_client_secret' with your actual client credentials
    client_id = 'nrvsopqC73obQxlXwRzVaZXeaPakf7uy6GHHTXmp'
    client_secret = 'uSJDRNaSmtkVgERpPAomw72QV0i0yhdGMggVKvF6T1yAeLMnOB4ZMr9qmFP0WOW5gXSx4UGauwUK8txm1nggvaQXoT7X6Gzftyve8buB5bgk84MM7dD0IdjeMEBNc8k7'
    email = request.data.get('email')
    password = request.data.get('password')


    existing_token = AccessToken.objects.filter(user__email=email).first()

    if existing_token and existing_token.is_valid():
        # If a valid token exists, use it
        return JsonResponse({'access_token': existing_token.token, 'user_id': existing_token.user.id, 'message': 'User already authenticated'})


    elif existing_token and existing_token.is_expired():
        # If the token is expired, refresh it
        new_access_token, new_refresh_token, user_id = refresh_access_token(existing_token.user.refresh_token.token, client_id, client_secret)
        return JsonResponse({'access_token': new_access_token, 'refresh_token': new_refresh_token, 'user_id': user_id, 'message': 'Token refresh successful'})



    data = {
        'grant_type': 'password',
        'username': 'admin@gmail.com',
        'password': 'a',
        'client_id': client_id,
        'client_secret': client_secret,
    }

    # Make a POST request to the OAuth2 token endpoint
    response = requests.post('http://localhost:8000/oauth2/token/', data=data)

    if response.status_code == 200:
        # Successfully authenticated, parse the response
        token_data = response.json()
        access_token = token_data.get('access_token')
        refresh_token = token_data.get('refresh_token')

        # Your logic after successful authentication
        user = authenticate(request, email=email, password=password)
        if user is not None:
            login(request, user)
            return JsonResponse({'access_token': access_token, 'refresh_token': refresh_token, 'user_id': user.id})
    else:
        # Authentication failed
        return JsonResponse({'error': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)


def refresh_access_token(refresh_token, client_id, client_secret):
    data = {
        'grant_type': 'refresh_token',
        'refresh_token': refresh_token,
        'client_id': client_id,
        'client_secret': client_secret,
    }

    # Make a POST request to the OAuth2 token refresh endpoint
    response = requests.post('http://localhost:8000/oauth2/token/', data=data)

    if response.status_code == 200:
        # Successfully refreshed, parse the response
        token_data = response.json()
        new_access_token = token_data.get('access_token')
        new_refresh_token = token_data.get('refresh_token')
        user_id = token_data.get('user_id')  # Assuming the server provides the user ID in the response
        return new_access_token, new_refresh_token, user_id
    else:
        # Token refresh failed
        return None, None, None


@api_view(['GET'])
@authentication_classes([OAuth2Authentication])
@permission_classes([IsAuthenticated])
def protected_view(request):
    user = request.user
    # Your logic for the protected view
    return Response({'message': f'Hello, {user.username}! This is a protected view.'})



==============================================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from .serializers import UserSerializer
from django.contrib.auth import get_user_model

class SignupAPIView(APIView):
    def post(self, request, *args, **kwargs):
        email = request.data.get('email')
        password = request.data.get('password')

        if not email or not password:
            return Response({'error': 'Both email and password are required.'}, status=status.HTTP_400_BAD_REQUEST)

        existing_user = get_user_model().objects.filter(email=email).first()

        if existing_user:
            return Response({'error': 'User with this email already exists.'}, status=status.HTTP_400_BAD_REQUEST)

        serializer = UserSerializer(data=request.data)

        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)












# management/commands/my_command.py

from django.core.management.base import BaseCommand
from first_app.models import Order  # Import the model from the first app
from second_app.models import Order2  # Import the model from the second app

class Command(BaseCommand):
    help = 'Copy specific data from Order model to Order2 model'

    def handle(self, *args, **options):
        # Retrieve data from the first database
        orders_from_first_database = Order.objects.filter(your_filtering_conditions_here)

        # Save specific data into the second database
        for order in orders_from_first_database:
            order2_instance = Order2(
                field1=order.field1,
                field2=order.field2,
                # Add other fields as needed
            )
            order2_instance.save()

        self.stdout.write(self.style.SUCCESS('Data copied successfully'))



------_-----------------------------

{
  "status": "not_yet_assigned",
  "assigned_to": "your_assigned_to_value",
  "order_numbers": ["order_number_1", "order_number_2", "order_number_3"]
}





# views.py

from rest_framework.generics import UpdateAPIView
from rest_framework.response import Response
from rest_framework import status

class OrdersPatchView(UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer

    def get_object(self):
        order_numbers = self.request.data.get('order_numbers', [])
        # Assuming you need a list of objects for multiple orders
        return Orders.objects.filter(order_number__in=order_numbers)

    def update(self, request, *args, **kwargs):
        instances = self.get_object()

        # Check if instances is None (orders not found)
        if not instances.exists():
            return Response({"error": "Invalid order_numbers."},
                            status=status.HTTP_404_NOT_FOUND)

        for instance in instances:
            serializer = self.get_serializer(instance, data=request.data, partial=True)
            serializer.is_valid(raise_exception=True)
            self.perform_update(serializer)

        return Response({"message": "Orders updated successfully."})





# serializers.py

class OrdersPatchSerializer(serializers.ModelSerializer):
    # ... (existing code)

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        status = validated_data.get('status', instance.status)
        order_numbers = validated_data.get('order_numbers', [])

        if status == 'manifest_pending':
            # ... (existing code)

        elif status == 'not_yet_assigned':
            # Update the assigned_to field for multiple orders
            assigned_to = validated_data.get('assigned_to')
            if assigned_to:
                instance.assigned_to = assigned_to
                instance.status = 'audit_in_progress'

        instance.save()
        return instance



# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import BarChart, Reference
from .models import YourModel
from datetime import datetime
import io
import os

def export_data_with_chart(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create bar chart using openpyxl
    chart = BarChart()
    values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    chart.add_data(values, titles_from_data=True)
    chart.set_categories(labels)
    chart.title = 'Data Chart'
    chart.x_axis.title = 'Date'
    chart.y_axis.title = 'Values'
    ws.add_chart(chart, 'E5')

    # Specify the local path to save the file
    local_file_path = '/path/to/your/local/directory/data_export_with_chart.xlsx'

    # Save Excel file locally
    wb.save(local_file_path)

    # Provide the file for download
    with open(local_file_path, 'rb') as local_file:
        response = HttpResponse(local_file.read(), content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        response['Content-Disposition'] = 'attachment; filename=data_export_with_chart.xlsx'

    return response

_------------------
radar_chart = RadarChart()
radar_values = Reference(ws, min_col=2, min_row=2, max_col=3, max_row=len(data) + 1)
radar_chart.add_data(radar_values, titles_from_data=True)
radar_chart.title = 'Data Radar Chart'
ws.add_chart(radar_chart, 'E95')

-----++++------
doughnut_chart = DoughnutChart()
doughnut_values = Reference(ws, min_col=2, min_row=2, max_col=2, max_row=len(data) + 1)
doughnut_chart.add_data(doughnut_values, titles_from_data=True)
doughnut_chart.title = 'Data Doughnut Chart'
ws.add_chart(doughnut_chart, 'E80')

--------------

area_chart = AreaChart()
area_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
area_chart.add_data(area_values, titles_from_data=True)
area_chart.title = 'Data Area Chart'
ws.add_chart(area_chart, 'E65')



____&&&______
scatter_chart = ScatterChart()
scatter_values = Reference(ws, min_col=2, min_row=2, max_col=3, max_row=len(data) + 1)
scatter_chart.add_data(scatter_values, titles_from_data=True)
scatter_chart.x_axis.title = 'X Values'
scatter_chart.y_axis.title = 'Y Values'
ws.add_chart(scatter_chart, 'E50')
--------------

# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import PieChart, Reference, BarChart, LineChart
from .models import YourModel
from datetime import datetime
import io

def export_data_with_charts(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create pie chart using openpyxl
    pie_chart = PieChart()
    data_points = Reference(ws, min_col=2, min_row=2, max_col=2, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    pie_chart.add_data(data_points, titles_from_data=True)
    pie_chart.set_categories(labels)
    pie_chart.title = 'Data Pie Chart'
    ws.add_chart(pie_chart, 'E5')

    # Create bar chart using openpyxl
    bar_chart = BarChart()
    bar_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    bar_labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    bar_chart.add_data(bar_values, titles_from_data=True)
    bar_chart.set_categories(bar_labels)
    bar_chart.title = 'Data Bar Chart'
    ws.add_chart(bar_chart, 'E20')

    # Create line chart using openpyxl
    line_chart = LineChart()
    line_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    line_labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    line_chart.add_data(line_values, titles_from_data=True)
    line_chart.set_categories(line_labels)
    line_chart.title = 'Data Line Chart'
    ws.add_chart(line_chart, 'E35')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export_with_charts.xlsx'
    wb.save(response)

    return response

---------------------

# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import BarChart, Reference
from .models import YourModel
from datetime import datetime
import io

def export_data_with_chart(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create bar chart using openpyxl
    chart = BarChart()
    values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    chart.add_data(values, titles_from_data=True)
    chart.set_categories(labels)
    chart.title = 'Data Chart'
    chart.x_axis.title = 'Date'
    chart.y_axis.title = 'Values'
    ws.add_chart(chart, 'E5')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export_with_chart.xlsx'
    wb.save(response)

    return response

------------------
# views.py
from django.http import HttpResponse
from django.shortcuts import render
import openpyxl
from .models import YourModel  # Import your model
from datetime import datetime

def export_data(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export.xlsx'
    wb.save(response)

    return response


------------+
# urls.py
from django.urls import path
from .views import generate_chart

urlpatterns = [
    path('generate-chart/', generate_chart, name='generate_chart'),
]

---------------
__________# views.py
from django.http import HttpResponse
from django.shortcuts import render
import openpyxl
from openpyxl.chart import BarChart, Reference
import matplotlib.pyplot as plt
import io

def generate_chart(request):
    # Your data retrieval logic here (replace this with your data)
    data = [
        ('Category 1', 10),
        ('Category 2', 20),
        ('Category 3', 15),
    ]

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.append(['Category', 'Value'])
    for row in data:
        ws.append(row)

    # Create bar chart using matplotlib
    plt.bar(range(2, len(data) + 2), [val[1] for val in data], tick_label=[val[0] for val in data])
    plt.title('Sample Chart')
    plt.xlabel('Categories')
    plt.ylabel('Values')

    # Save matplotlib chart to BytesIO buffer
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    plt.close()

    # Add chart image to Excel file
    chart_image = openpyxl.drawing.image.Image(buffer)
    ws.add_image(chart_image, 'D5')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=chart_example.xlsx'
    wb.save(response)

    return response

pip install openpyxl matplotlib

_-------+++##£££££&&&&&&&&&&&&--++++++-----
check_list = models.FileField(upload_to='uploads/', null=True, blank=True)
-----------------------------------------------------------------------------------------
# urls.py

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # ... your existing urlpatterns ...
]

# Serve media files during development
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

---------------------------------------------------------------------------------------------

# settings.py

# ...

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / "media"  # assuming BASE_DIR is the root directory of your Django project

# ...


--------------------------------------------------------------------------------------------------

class OrdersSerializer(serializers.ModelSerializer):
    class Meta:
        model = Orders
        fields = ('employee','order_number', 'tracking_number', 'borrowers_first_name', 'borrowers_last_name', 'additional_comments','check_received','check_received_amount','status')
    
    def create(self, validated_data):
        order_number = validated_data.get('order_number')
        validated_data['status'] = 'manifest_pending'
        validated_data['employee'] = validated_data.get('employee')
        existing_order = Orders.objects.filter(order_number=order_number).first()
        if existing_order:
            raise serializers.ValidationError({"order_number": ["Order with this order_number already exists."]})
        
        order = Orders.objects.create(**validated_data)
        return order


class OrdersPatchSerializer(serializers.ModelSerializer):

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date','loan_number', 'lender', 'state', 'county','zipcode','assigned_to','status','check_list','audit_status','audit_comment')

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        status = validated_data.get('status', instance.status)
        if status == 'manifest_pending':
            instance.entered_date = validated_data.get('entered_date', instance.entered_date)
            instance.closing_date = validated_data.get('closing_date', instance.closing_date)
            instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
            instance.loan_number = validated_data.get('loan_number', instance.loan_number)
            instance.lender = validated_data.get('lender', instance.lender)
            instance.state = validated_data.get('state', instance.state)
            instance.county = validated_data.get('county', instance.county)
            instance.zipcode = validated_data.get('zipcode', instance.zipcode)
            instance.status = 'not_yet_assigned'

        elif status == 'not_yet_assigned':
            # Update the assigned_to field
            assigned_to = validated_data.get('assigned_to')
            print(assigned_to)
            if assigned_to:
                instance.assigned_to = assigned_to
                instance.status = 'audit_in_progress'

        elif status == 'audit_in_progress':
            file_data = validated_data.get('check_list')

            if file_data:
                # Save the file in the 'media' folder
                with open(f'media/{file_data.name}', 'wb') as file:
                    for chunk in file_data.chunks():
                        file.write(chunk)

                # Update the 'check_list' field in the instance
                instance.check_list = file_data.name
                instance.audit_status = validated_data.get('audit_status', instance.audit_status)
                instance.audit_comment = validated_data.get('audit_comment', instance.audit_comment)
                if instance.audit_status == 'pass':
                    instance.status = 'audit_pass'
                else:
                    instance.status = 'audit_fail'

        else:
            raise serializers.ValidationError(f"Invalid status: {status}.")
        
        instance.save()
        return instance

---------------------------------------------------------------------------------------------------------
# admin.py
from django.contrib import admin
from import_export.admin import ImportExportModelAdmin
from .models import State, County
from .resources import StateResource, CountyResource

@admin.register(State)
class StateAdmin(ImportExportModelAdmin):
    resource_class = StateResource

@admin.register(County)
class CountyAdmin(ImportExportModelAdmin):
    resource_class = CountyResource


-------------------------------------------------------------------------------------------------------------------------
# resources.py
from import_export import resources, fields
from import_export.widgets import ForeignKeyWidget
from .models import State, County

class StateResource(resources.ModelResource):
    class Meta:
        model = State
        fields = ('state_id', 'state_name')
        import_id_fields = ('state_id',)

class CountyResource(resources.ModelResource):
    state = fields.Field(
        column_name='state_id',
        attribute='state',
        widget=ForeignKeyWidget(State, 'state_id')
    )

    class Meta:
        model = County
        fields = ('county_id', 'county_name', 'state')
        import_id_fields = ('county_id',)

-------------------------------------------------------------------------------------------------------

# models.py
from django.db import models

class State(models.Model):
    state_id = models.AutoField(primary_key=True)
    state_name = models.CharField(max_length=255)

class County(models.Model):
    county_id = models.AutoField(primary_key=True)
    county_name = models.CharField(max_length=255)
    state = models.ForeignKey(State, on_delete=models.CASCADE)


------------------------------------------------------------------------------------------------------------
INSTALLED_APPS = [
    # ...
    'import_export',
    # ...
]

-------------------------------------------------------------------------------------------------------------
pip install django-import-export

--------------------------------------------------------------------------------------------------------------------
# views.py
from rest_framework.response import Response
from rest_framework import status

class OrdersPatchView(generics.UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer
    lookup_field = 'order_number'  # Assuming 'order_number' is part of the URL kwargs

    def get_object(self):
        order_number = self.kwargs.get(self.lookup_field)
        status = self.kwargs.get('status')  # Assuming 'status' is part of the URL kwargs

        # Add additional condition based on the 'status'
        if status == 'manifest_pending':
            return self.queryset.get(order_number=order_number, status='manifest pending')
        elif status == 'not_yet_assigned':
            return self.queryset.get(order_number=order_number, status='not yet assigned')
        else:
            # Return None or raise a 404 depending on your use case
            return None

    def update(self, request, *args, **kwargs):
        instance = self.get_object()

        # Check if instance is None (order not found or invalid status)
        if instance is None:
            return Response({"error": "Invalid order_number or status."},
                            status=status.HTTP_404_NOT_FOUND)

        serializer = self.get_serializer(instance, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        return Response(serializer.data)

-------------------------------------------------------------------------------------------------------------------------------
# serializers.py

class OrdersPatchSerializer(serializers.ModelSerializer):

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date', 'loan_number', 'lender', 'state', 'county', 'zipcode', 'status', 'assigned_to')

    def update(self, instance, validated_data):
        # Check the status and update the assigned_to field if needed
        status = validated_data.get('status', instance.status)
        if status == 'manifest pending':
            # Update the main Orders model fields
            instance.entered_date = validated_data.get('entered_date', instance.entered_date)
            instance.closing_date = validated_data.get('closing_date', instance.closing_date)
            instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
            instance.loan_number = validated_data.get('loan_number', instance.loan_number)
            instance.lender = validated_data.get('lender', instance.lender)
            instance.state = validated_data.get('state', instance.state)
            instance.county = validated_data.get('county', instance.county)
            instance.zipcode = validated_data.get('zipcode', instance.zipcode)
        elif status == 'not yet assigned':
            # Update the assigned_to field
            assigned_to = validated_data.get('assigned_to')
            if assigned_to:
                instance.assigned_to = assigned_to
        else:
            raise serializers.ValidationError(f"Invalid status: {status}.")

        instance.save()
        return instance


----------------------------------------------------------------------------------------------------------------------------
models.py
from django.db import models
from django.contrib.auth.models import AbstractUser
from django.db import models
from .managers import *

class CustomUser(AbstractUser):
    username = None
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15, blank=True, null=True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    objects = CustomUserManager()

    def __str__(self):
        return self.email


class Orders(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    order_number = models.CharField(max_length=255)
    tracking_number = models.CharField(max_length=255)
    borrowers_first_name = models.CharField(max_length=255)
    borrowers_last_name = models.CharField(max_length=255)
    additional_comments = models.TextField()
    file_url = models.URLField()
    entered_date = models.DateTimeField(null=True, blank=True)
    closing_date = models.DateTimeField(null=True, blank=True)
    disbursment_date = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    zipcode = models.CharField(max_length=10)

class Check(models.Model):
    CHECK_RECEIVED_CHOICES = [
        ('yes', 'Yes'),
        ('no', 'No'),
        ('missing', 'Missing'),
    ]
    order = models.ForeignKey(Orders, on_delete=models.CASCADE,related_name='checks')
    check_received = models.CharField(choices=CHECK_RECEIVED_CHOICES, max_length=10)
    check_received_amount = models.IntegerField(null=True, blank=True)

class Lender(models.Model):
    LENDER_CHOICES = [
        ('affinity', 'Affinity'),
        ('boa', 'Bank of America'),
        ('boa_heloc', 'Bank of America HELOC'),
        # Add other choices
    ]
    order = models.OneToOneField(Orders, on_delete=models.CASCADE)
    lender_type = models.CharField(choices=LENDER_CHOICES, max_length=20)

class State(models.Model):
    STATE_CHOICES = [
        ('jharkhand', 'Jharkhand'),
        ('bihar', 'Bihar'),
        # Add other choices
    ]
    order = models.OneToOneField(Orders, on_delete=models.CASCADE)
    state_type = models.CharField(choices=STATE_CHOICES, max_length=20)

class County(models.Model):
    COUNTY_CHOICES = [
        ('ranchi', 'Ranchi'),
        ('jamshedpur', 'Jamshedpur'),
        # Add other choices
    ]
    state = models.ForeignKey(State, on_delete=models.CASCADE)
    county_type = models.CharField(choices=COUNTY_CHOICES, max_length=20)
--------------------------------------------------------------------------------------------

managers.py
# customuser/managers.py
from django.contrib.auth.models import BaseUserManager

class CustomUserManager(BaseUserManager):
    def create_user(self, email, phone_number=None, password=None, **extra_fields):
        if not email:
            raise ValueError('The Email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, phone_number=phone_number, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        return self.create_user(email, password, **extra_fields)
--------------------------------------------------------------------------------------------------

serializers.py

from rest_framework import serializers
from .models import *

class CustomUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = '__all__'

class CheckListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Check
        fields = '__all__'

        
class OrdersListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Orders
        fields = '__all__'

class CustomUserCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ('email', 'phone_number', 'password')
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        user = CustomUser.objects.create_user(**validated_data)
        return user


class CheckSerializer(serializers.ModelSerializer):
    class Meta:
        model = Check
        fields = ('check_received', 'check_received_amount')

    def validate(self, data):
        check_received = data.get('check_received')
        check_received_amount = data.get('check_received_amount')

        if check_received == 'yes' and not check_received_amount:
            raise serializers.ValidationError("check_received_amount is required when check_received is 'yes'.")

        return data

class OrdersSerializer(serializers.ModelSerializer):
    check = CheckSerializer(many=True)
    user = 1
    class Meta:
        model = Orders
        fields = ('user','order_number', 'tracking_number', 'borrowers_first_name', 'borrowers_last_name', 'additional_comments', 'check')
    
    def create(self, validated_data):
        check_data = validated_data.pop('check',None)
        order_number = validated_data.get('order_number')
        validated_data['user'] = validated_data.get('user')
        existing_order = Orders.objects.filter(order_number=order_number).first()
        if existing_order:
            raise serializers.ValidationError({"order_number": ["Order with this order_number already exists."]})
        
        order = Orders.objects.create(**validated_data)
        if check_data:
            for check_data in check_data:
                Check.objects.create(order=order, **check_data)
        return order

---------------------------------------------------------------------
views.py
from rest_framework import generics
from rest_framework.response import Response
from rest_framework import status
from django.db.models import Prefetch

from .models import *
from .serializers import *

class CustomUserListView(generics.ListAPIView):
    queryset = CustomUser.objects.all()
    serializer_class = CustomUserSerializer

class CustomUserCreateView(generics.CreateAPIView):
    queryset = CustomUser.objects.all()
    serializer_class = CustomUserCreateSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)


class OrdersListView(generics.ListAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersListSerializer

    def get_queryset(self):
        # Customize the queryset to include related Check data
        return Orders.objects.prefetch_related('checks').all()

    def get_check_data(self, order_id):
        # Your logic to get Check data for a specific order
        checks = Check.objects.filter(order_id=order_id).values('check_received', 'check_received_amount')
        checks_list = list(checks)
        return checks_list

    def list(self, request, *args, **kwargs):
        # Override the list method to customize serialized data
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        print(serializer)
        # Customize serialized data to include Check details
        for order_data in serializer.data:
            print(order_data)
            order_id = order_data['id']
            check_data = self.get_check_data(order_id)
            order_data['check'] = check_data

        return Response(serializer.data)

class OrdersCreateView(generics.CreateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersSerializer
---------------------------------------------------------------------------------


urls.py

from django.urls import path
from .views import *

urlpatterns = [
    path('users/', CustomUserListView.as_view(), name='user-list'),
    path('users/create/', CustomUserCreateView.as_view(), name='user-create'),
    path('orders/create/', OrdersCreateView.as_view(), name='create-order'),
    path('orders/list/', OrdersListView.as_view(), name='order-list'),
]



-------------------------------------------------------------------------------------------------------------------------------------------------------------

# serializers.py
from rest_framework import serializers
from .models import Orders, Lender, State, County

class LenderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Lender
        fields = ('lender_type',)

class StateSerializer(serializers.ModelSerializer):
    class Meta:
        model = State
        fields = ('state_type',)

class CountySerializer(serializers.ModelSerializer):
    class Meta:
        model = County
        fields = ('county_type',)

class OrdersPatchSerializer(serializers.ModelSerializer):
    lender = LenderSerializer(required=False)
    state = StateSerializer(required=False)
    county = CountySerializer(required=False)

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date', 'lender', 'state', 'county')

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        instance.entered_date = validated_data.get('entered_date', instance.entered_date)
        instance.closing_date = validated_data.get('closing_date', instance.closing_date)
        instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
        instance.save()

        # Update the related Lender, State, County models
        lender_data = validated_data.get('lender')
        state_data = validated_data.get('state')
        county_data = validated_data.get('county')

        if lender_data:
            lender, created = Lender.objects.get_or_create(order=instance)
            lender.lender_type = lender_data.get('lender_type')
            lender.save()

        if state_data:
            state, created = State.objects.get_or_create(order=instance)
            state.state_type = state_data.get('state_type')
            state.save()

        if county_data:
            county, created = County.objects.get_or_create(state=state)
            county.county_type = county_data.get('county_type')
            county.save()

        return instance

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
# views.py
from rest_framework import generics
from .models import Orders
from .serializers import OrdersPatchSerializer

class OrdersPatchView(generics.UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer
    lookup_field = 'order_number'  # Assuming order_number is unique

    def get_object(self):
        order_number = self.kwargs.get(self.lookup_field)
        return self.queryset.get(order_number=order_number)


-------------------------------------------------------------------------------------------------------------
# urls.py
from django.urls import path
from .views import OrdersPatchView

urlpatterns = [
    path('orders/<str:order_number>/', OrdersPatchView.as_view(), name='orders-patch'),
    # Add other URL patterns as needed
]


-->

<html>
  <body>
    <h1> hey </h1>
  </body>
</html>





<!-- 


tests.py

# myapp/tests.py
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from .models import CustomUser, Orders, Employee, Check

class CustomUserTests(TestCase):
    def test_create_user(self):
        response = self.client.post('/api/users/create/', {
            'email': 'test@example.com',
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(CustomUser.objects.count(), 1)
        user = CustomUser.objects.get()
        self.assertEqual(user.email, 'test@example.com')

class OrdersTests(APITestCase):
    def setUp(self):
        # Create a user for testing
        self.user = CustomUser.objects.create(email='test@example.com', password='testpassword')
        # Create an employee for testing
        self.employee = Employee.objects.create(user=self.user, employee_id='123', designation='Test', process='Test', branch='Test', reporting_to=self.user)
        
    def test_create_order(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Orders.objects.count(), 1)
        order = Orders.objects.get()
        self.assertEqual(order.order_number, '123456')

    def test_list_orders(self):
        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)  # Assuming no orders in the test database

    # Add more tests as needed for other APIs


--------------------------------------------------------------------------------------------------------

# myapp/tests.py
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from .models import CustomUser, Orders, Employee, Check

class CustomUserTests(APITestCase):
    def test_create_user(self):
        response = self.client.post('/api/users/create/', {
            'email': 'test@example.com',
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(CustomUser.objects.count(), 1)
        user = CustomUser.objects.get()
        self.assertEqual(user.email, 'test@example.com')

    def test_create_user_invalid_data(self):
        response = self.client.post('/api/users/create/', {
            'email': 'invalidemail',  # Invalid email format
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(CustomUser.objects.count(), 0)

class OrdersTests(APITestCase):
    def setUp(self):
        self.user = CustomUser.objects.create(email='test@example.com', password='testpassword')
        self.employee = Employee.objects.create(user=self.user, employee_id='123', designation='Test', process='Test', branch='Test', reporting_to=self.user)
        
    def test_create_order(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Orders.objects.count(), 1)
        order = Orders.objects.get()
        self.assertEqual(order.order_number, '123456')

    def test_create_order_invalid_data(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': 'invalid_order',  # Invalid order_number format
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(Orders.objects.count(), 0)

    def test_list_orders(self):
        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)  # Assuming no orders in the test database

    # Add more tests as needed for other APIs
------------------------------------------------------------------------------------------------------------------------------
# myapp/tests.py
# ...

class OrdersTests(APITestCase):
    # ... (previous test cases)

    def test_create_order_unauthenticated(self):
        # Ensure creating an order without authentication returns 401 Unauthorized
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(Orders.objects.count(), 0)

    def test_list_orders_with_checks(self):
        # Ensure listing orders also includes check details
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        Check.objects.create(order=order, check_received='yes', check_received_amount=500)
        Check.objects.create(order=order, check_received='yes', check_received_amount=600)

        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(len(response.data[0]['check']), 2)

    def test_patch_order_manifest_pending(self):
        # Ensure patching an order with 'manifest pending' status updates fields
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        self.client.force_authenticate(self.user)
        response = self.client.patch(f'/api/orders/{order.order_number}/', {
            'status': 'manifest pending',
            'entered_date': '2023-01-01',
            'closing_date': '2023-02-01',
            'disbursment_date': '2023-03-01',
            'loan_number': 12345,
            'lender': 'Test Lender',
            'state': 'California',
            'county': 'Los Angeles',
            'zipcode': '90001'
        })

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        updated_order = Orders.objects.get(pk=order.pk)
        self.assertEqual(updated_order.entered_date, '2023-01-01')
        self.assertEqual(updated_order.closing_date, '2023-02-01')
        self.assertEqual(updated_order.disbursment_date, '2023-03-01')
        self.assertEqual(updated_order.loan_number, 12345)
        self.assertEqual(updated_order.lender, 'Test Lender')
        self.assertEqual(updated_order.state, 'California')
        self.assertEqual(updated_order.county, 'Los Angeles')
        self.assertEqual(updated_order.zipcode, '90001')

    def test_patch_order_not_assigned(self):
        # Ensure patching an order with 'not yet assigned' status updates 'assigned_to'
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        self.client.force_authenticate(self.user)
        response = self.client.patch(f'/api/orders/{order.order_number}/', {
            'status': 'not yet assigned',
            'assigned_to': 'new_assignee@example.com'
        })

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        updated_order = Orders.objects.get(pk=order.pk)
        self.assertEqual(updated_order.assigned_to, 'new_assignee@example.com')

    # Add more test cases as needed for other scenarios
----------------------------------------------------------------------------------------------------------------------

python manage.py test myapp.tests

----------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++=============================-----------------------------------------------------------


# project_graphql/schema.py
import graphene
from graphene_django.types import DjangoObjectType
from .models import Order
import requests

class OrderType(DjangoObjectType):
    class Meta:
        model = Order

class Query(graphene.ObjectType):
    all_orders = graphene.List(OrderType)

    def resolve_all_orders(self, info):
        return Order.objects.all()

class FetchAndSaveOrdersMutation(graphene.Mutation):
    class Arguments:
        api_url = graphene.String(required=True)
        params = graphene.JSONString(required=True)  # JSON string representing parameters to send to the API

    success = graphene.Boolean()

    def mutate(self, info, api_url, params):
        try:
            # Make a request to the specified API URL with the provided parameters
            response = requests.get(api_url, params=params)
            response.raise_for_status()  # Raise an error for HTTP errors

            # Parse the JSON response assuming it is in the expected format
            data = response.json()

            # Update the Order model based on the fetched data
            for order_data in data:
                Order.objects.create(
                    order_id=order_data.get('order_id'),
                    tracking_number=order_data.get('tracking_number'),
                    borrowers_first_name=order_data.get('borrowers_first_name'),
                    borrowers_last_name=order_data.get('borrowers_last_name'),
                    additional_comments=order_data.get('additional_comments'),
                    # Add other fields as needed
                )

            success = True  # Set to True if the operation is successful
        except Exception as e:
            print(f"Error fetching and saving Orders: {str(e)}")
            success = False

        return FetchAndSaveOrdersMutation(success=success)

class Mutation(graphene.ObjectType):
    fetch_and_save_orders = FetchAndSaveOrdersMutation.Field()

schema = graphene.Schema(query=Query, mutation=Mutation)


----------------------------------------------------------------------------------------------------------------------------------------
mutation {
  fetch_and_save_orders(api_url: "http://example.com/api/orders", params: "{\"status\": \"shipped\", \"limit\": 10}") {
    success
  }
}
-------------------------------------------------------------------------------------------------

mutation {
  fetch_and_save_orders(api_url: "http://example.com/api/orders", ids: [1, 2, 3]) {
    success
  }
}
------------------------##############################################################################---------------------------------------------------------------------

// EditOrder.js
import React, { useState } from 'react';
import { useMutation } from '@apollo/client';
import gql from 'graphql-tag';

const EDIT_ORDER = gql`
  mutation EditOrder($api_url: String!, $params: String!) {
    fetch_and_save_orders(api_url: $api_url, params: $params) {
      success
    }
  }
`;

const EditOrder = ({ orderId, currentAmount }) => {
  const [newAmount, setNewAmount] = useState(currentAmount);

  const [editOrder] = useMutation(EDIT_ORDER);

  const handleEdit = () => {
    // Prepare the parameters for the API request
    const params = JSON.stringify({
      id: orderId,
      amount: newAmount,
      // Add other parameters as needed
    });

    // Define the API URL
    const apiUrl = 'http://example.com/api/edit_order';

    // Make the mutation request
    editOrder({
      variables: {
        api_url: apiUrl,
        params: params,
      },
    })
      .then((response) => {
        // Handle the response if needed
        console.log(response);
      })
      .catch((error) => {
        // Handle errors
        console.error(error);
      });
  };

  return (
    <div>
      <label htmlFor="newAmount">New Amount:</label>
      <input
        type="number"
        id="newAmount"
        value={newAmount}
        onChange={(e) => setNewAmount(e.target.value)}
      />
      <button onClick={handleEdit}>Edit Order</button>
    </div>
  );
};

export default EditOrder;
-----------------------------------------------------------------#################################################################-------------------------------------------

// App.js
import React from 'react';
import { ApolloProvider, ApolloClient, InMemoryCache } from '@apollo/client';
import EditOrder from './EditOrder';

// Define your GraphQL endpoint
const uri = 'http://localhost:8000/graphql/';

const client = new ApolloClient({
  uri,
  cache: new InMemoryCache(),
});

const orders = [
  // Sample order data
  { id: 1, amount: 100 },
  { id: 2, amount: 150 },
  // Add more orders as needed
];

const App = () => {
  return (
    <ApolloProvider client={client}>
      <div>
        {orders.map((order) => (
          <div key={order.id}>
            <p>Order ID: {order.id}</p>
            <p>Amount: {order.amount}</p>
            <EditOrder orderId={order.id} currentAmount={order.amount} />
            <hr />
          </div>
        ))}
      </div>
    </ApolloProvider>
  );
};

export default App;






-->
