<!--


# serializers.py
from rest_framework import serializers

class SignupSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True, required=False)  # Password is optional in the first step




++++++++++++++++++++++++++++++++++
# views.py
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from .serializers import SignupSerializer
from django.contrib.auth.models import User

class SignupView(APIView):
    def post(self, request, *args, **kwargs):
        serializer = SignupSerializer(data=request.data)
        if serializer.is_valid():
            email = serializer.validated_data['email']
            password = serializer.validated_data['password']

            # Check if the email already exists
            if User.objects.filter(email=email).exists():
                return Response({'error': 'Email already exists'}, status=status.HTTP_400_BAD_REQUEST)

            # Proceed with the signup process
            user = User.objects.create_user(email=email, password=password)

            return Response({'message': 'Signup successful'}, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)





---------------------

from oauth2_provider.models import RefreshToken

# Assuming `refresh_token` is the refresh token you want to check
try:
    # Try to get the corresponding refresh token
    refresh_token_instance = RefreshToken.objects.get(token=refresh_token)
    
    # Check if the refresh token is expired
    if refresh_token_instance.access_token.expires < timezone.now():
        # Expired, re-authenticate the user and obtain new tokens
        # Redirect the user to the authentication page or initiate a new authentication process
        # Request new access and refresh tokens after successful authentication
        # ...

    # Use the current refresh token for the refresh operation
    # ...
except RefreshToken.DoesNotExist:
    # The refresh token doesn't exist; handle accordingly
    # ...




# myapp/views.py

from rest_framework import status
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from myapp.serializers import UserSerializer  # Import your UserSerializer
from django.http import JsonResponse

@api_view(['POST'])
@permission_classes([AllowAny])
def signup(request):
    serializer = UserSerializer(data=request.data)

    if serializer.is_valid():
        user, access_token, refresh_token = serializer.save()

        # You can customize the response based on your needs
        response_data = {
            'access_token': access_token.token,
            'refresh_token': refresh_token.token,
            'user_id': user.id,
            'message': 'User signup and token creation successful'
        }

        return JsonResponse(response_data, status=status.HTTP_201_CREATED)
    else:
        return JsonResponse({'error': 'Invalid data'}, status=status.HTTP_400_BAD_REQUEST)








# myapp/serializers.py

from rest_framework import serializers
from django.contrib.auth.models import User
from oauth2_provider.models import Application, AccessToken, RefreshToken

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'password']

    def create(self, validated_data):
        # Create a new user
        user = User.objects.create_user(**validated_data)

        # Replace 'your_client_id' and 'your_client_secret' with the actual client credentials
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'

        try:
            # Try to find an existing application with the given client credentials
            application = Application.objects.get(client_id=client_id, client_secret=client_secret)
        except Application.DoesNotExist:
            # Handle the case where the application does not exist
            # You may raise an exception, log a message, or handle it based on your requirements
            raise Exception('Application not found with the provided client credentials')

        # Create an access token for the user with the existing application
        access_token = AccessToken.objects.create(
            user=user,
            application=application,
            scope='read write',
        )

        # Create a refresh token for the user with the existing application
        refresh_token = RefreshToken.objects.create(
            user=user,
            application=application,
        )

        return user, access_token, refresh_token











# myapp/views.py

from rest_framework import status
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from oauth2_provider.models import Application, AccessToken, RefreshToken
from django.contrib.auth.models import User
from django.http import JsonResponse

@api_view(['POST'])
@permission_classes([AllowAny])
def signup(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' with your actual client ID
    client_id = 'your_client_id'
    
    # Your signup logic here...
    # For example, create a new user instance and save it to the database
    user = User.objects.create(username=request.data.get('username'), password=request.data.get('password'))

    # Create an OAuth2 Application (client) for the user
    application, _ = Application.objects.get_or_create(
        user=user,
        authorization_grant_type='password',
        client_type='confidential',
        name=f"{user.username}'s Application",
        client_id=client_id,
    )

    # Create an access token for the user
    access_token = AccessToken.objects.create(
        user=user,
        application=application,
        scope='read write',
    )

    # Create a refresh token for the user
    refresh_token = RefreshToken.objects.create(
        user=user,
        application=application,
    )

    return JsonResponse({
        'access_token': access_token.token,
        'refresh_token': refresh_token.token,
        'user_id': user.id,
        'message': 'User signup and token creation successful'
    })

@api_view(['POST'])
@permission_classes([AllowAny])
def signin(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' with your actual client ID
    client_id = 'your_client_id'
    access_token = request.data.get('access_token')

    # Verify the access token
    try:
        existing_token = AccessToken.objects.get(token=access_token, application__client_id=client_id)
        
        # If a valid token exists, return user details
        return JsonResponse({
            'user_id': existing_token.user.id,
            'message': 'User authenticated with existing token'
        })
    except AccessToken.DoesNotExist:
        # Token does not exist or is invalid
        return JsonResponse({'error': 'Invalid access token'}, status=status.HTTP_401_UNAUTHORIZED)





##################№#######)##############
# myapp/urls.py

from django.urls import path
from .views import refresh_token, protected_view

urlpatterns = [
    path('refresh-token/', refresh_token, name='refresh_token'),
    path('protected-view/', protected_view, name='protected_view'),
    # Add other URLs as needed
]


######################################

# myapp/views.py

import requests
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from django.http import JsonResponse

@api_view(['POST'])
@permission_classes([AllowAny])
def refresh_token(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' and 'your_client_secret' with your actual client credentials
    client_id = 'your_client_id'
    client_secret = 'your_client_secret'
    refresh_token = request.data.get('refresh_token')

    data = {
        'grant_type': 'refresh_token',
        'refresh_token': refresh_token,
        'client_id': client_id,
        'client_secret': client_secret,
    }

    # Make a POST request to the OAuth2 token refresh endpoint
    response = requests.post('http://localhost:8000/oauth2/token/', data=data)

    if response.status_code == 200:
        # Successfully refreshed, parse the response
        token_data = response.json()
        access_token = token_data.get('access_token')
        refresh_token = token_data.get('refresh_token')

        # Your logic after successful token refresh
        return JsonResponse({'access_token': access_token, 'refresh_token': refresh_token, 'message': 'Token refresh successful'})
    else:
        # Token refresh failed
        return JsonResponse({'error': 'Token refresh failed'}, status=response.status_code)



---_--------------------------777777777-------

path('oauth2/', include('oauth2_provider.urls', namespace='oauth2_provider')),
]


AUTHENTICATION_CLASSES = [
    'oauth2_provider.contrib.rest_framework.OAuth2Authentication',
    # ... (other authentication classes, if needed)
]

==============--------------------======================================--------------------------====================----------======
_________++++++++++++++++++++++++++++++++++++++++++______________________++++++++++++++++++++++++++++++++++++++___________________+++++

To achieve this, you can implement a single sign-on (SSO) approach between the two projects. One way to implement SSO is by using OAuth 2.0. In this scenario, the first project (http://127.0.0.1:8000/signin/) acts as an OAuth 2.0 Authorization Server, and the second project (http://127.0.0.1:8001/dashboard/) acts as the OAuth 2.0 Resource Server.

Here are the high-level steps you can follow:

Configure OAuth 2.0 in the Sign-In Project (Authorization Server):

Configure the Django OAuth Toolkit or another OAuth 2.0 provider in your sign-in project.
Set up client credentials for the second project (http://127.0.0.1:8001/dashboard/) in the Authorization Server.
Redirect from the Dashboard Project to the Sign-In Project for Authentication:

When a user tries to access the dashboard in the second project without being authenticated, redirect them to the authorization URL of the first project for authentication.
User Authentication in the Sign-In Project:

In the first project, handle the user's authentication and issue an access token upon successful authentication.
Redirect Back to the Dashboard Project with the Access Token:

After authentication in the first project, redirect the user back to the dashboard in the second project with the access token.
Access Dashboard Resources with the Access Token:

In the second project, validate the access token received from the first project and grant access to protected resources.
Below is a simplified example using OAuth 2.0 and Django OAuth Toolkit. Note that this is a basic illustration, and you may need to adjust it based on your specific requirements and OAuth 2.0 provider.

python
Copy code
# Sign-In Project (http://127.0.0.1:8000/signin/)

# views.py
from django.shortcuts import redirect
from django.urls import reverse
from django.http import JsonResponse
from oauth2_provider.models import Application, AccessToken
from django.contrib.auth import authenticate, login

def signin(request):
    # Handle user authentication
    # Issue access token upon successful authentication
    # ...

    # Redirect back to the dashboard with the access token
    dashboard_url = 'http://127.0.0.1:8001/dashboard/'
    return redirect(f'{dashboard_url}?access_token={access_token}')

# Dashboard Project (http://127.0.0.1:8001/dashboard/)

# views.py
from django.http import HttpResponse
from django.views import View

class DashboardView(View):
    def get(self, request):
        access_token = request.GET.get('access_token')

        # Validate the access token with the Authorization Server
        if self.validate_access_token(access_token):
            return HttpResponse('Welcome to the Dashboard!')
        else:
            # Redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

    def validate_access_token(self, access_token):
        # Use OAuth 2.0 token validation logic here
        # ...

        return True  # Placeholder; replace with actual validation logic
In this example, the signin view in the sign-in project handles user authentication and redirects back to the dashboard project with the access token as a query parameter. The DashboardView in the dashboard project validates the access token and either grants access to the dashboard or redirects to the sign-in project for authentication.

Please note that this is a simplified example, and you'll need to implement proper OAuth 2.0 flows, handle security considerations, and integrate the Django OAuth Toolkit or another OAuth 2.0 provider according to your project's needs.

User
what will be the code for this?

def validate_access_token(self, access_token):
ChatGPT
To validate an access token, you typically need to make a request to the OAuth 2.0 Authorization Server's token validation endpoint. The OAuth 2.0 provider (in your case, Django OAuth Toolkit) should provide an endpoint for token validation.

Here's an example of how you might implement the validate_access_token method using requests to validate the access token with Django OAuth Toolkit:

python
Copy code
# Dashboard Project (http://127.0.0.1:8001/dashboard/)

# views.py
from django.http import HttpResponse
from django.views import View
import requests

class DashboardView(View):
    def get(self, request):
        access_token = request.GET.get('access_token')

        # Validate the access token with the Authorization Server
        if self.validate_access_token(access_token):
            return HttpResponse('Welcome to the Dashboard!')
        else:
            # Redirect to the Sign-In Project for authentication
            signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url)

    def validate_access_token(self, access_token):
        # Replace 'your_token_validation_endpoint' with the actual token validation endpoint provided by your OAuth 2.0 provider
        token_validation_endpoint = 'http://127.0.0.1:8000/o/introspect/'

        # Replace 'your_client_id' and 'your_client_secret' with the actual client credentials for the Dashboard project
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'

        # Make a request to the token validation endpoint
        response = requests.post(
            token_validation_endpoint,
            data={'token': access_token, 'client_id': client_id, 'client_secret': client_secret},
        )

        if response.status_code == 200:
            # Token is valid
            return True
        else:
            # Token is invalid
            return False
Please note that the exact endpoint and parameters for token validation may vary depending on the OAuth 2.0 provider you are using. Make sure to consult the documentation of your OAuth 2.0 provider (Django OAuth Toolkit in this case) for details on token validation.

Also, ensure that you handle errors, such as network issues or unexpected responses, gracefully in a production setting. The example above assumes a successful response status code of 200 for simplicity.

User
# Replace 'your_token_validation_endpoint' with the actual token validation endpoint provided by your OAuth 2.0 provider
        token_validation_endpoint = 'http://127.0.0.1:8000/o/introspect/'

which url should I give here?
ChatGPT
In Django OAuth Toolkit, the introspect endpoint is used to validate access tokens. The default introspect endpoint URL is usually /o/introspect/ relative to the base URL of your OAuth 2.0 provider.

However, the actual URL may vary depending on your Django project's configuration. You can check your Django project's urls.py to find the correct endpoint. If you haven't customized it, the default introspect endpoint is often available at /o/introspect/.

Here's an example of what the urls.py might look like in your Django OAuth Toolkit-enabled project:

python
Copy code
# Your Django OAuth Toolkit-enabled project's urls.py

from django.urls import path
from oauth2_provider.views.introspect import IntrospectTokenView

urlpatterns = [
    # ... other URL patterns ...

    # Introspect endpoint
    path('o/introspect/', IntrospectTokenView.as_view(), name='introspect-token'),

    # ... other URL patterns ...
]
In this case, the introspect endpoint is available at /o/introspect/.

If you have customized the URL pattern or are using a different OAuth 2.0 provider, refer to the provider's documentation or check the relevant configuration in your Django project. The introspect endpoint is specifically designed for token introspection and validation.

User
generally what is the the actual token validation endpoint provided by your OAuth 2.0 provider?
ChatGPT
The token validation endpoint in OAuth 2.0 is specified by the OAuth 2.0 Token Introspection standard. The endpoint is used to check the validity of an access token, and the response from this endpoint provides information about the token, such as its validity, scope, and associated user.

The typical URL for the token validation endpoint is /oauth2/introspect/ or /o/introspect/. However, the exact endpoint URL can vary based on the OAuth 2.0 provider you are using, as different providers may have different conventions.

For example:

Django OAuth Toolkit: /o/introspect/
Keycloak: /protocol/openid-connect/token/introspect
Auth0: /oauth/token/introspect
Okta: /oauth2/v1/introspect
It's essential to consult the documentation of your specific OAuth 2.0 provider to determine the correct token validation endpoint. The provider's documentation should specify the endpoint's URL and any additional parameters required for the introspection request.

If you are using Django OAuth Toolkit, the default introspect endpoint can often be found in your Django project's urls.py. If you have customized the endpoint, refer to your project's configuration.

In any case, the token validation endpoint is an essential part of OAuth 2.0, and understanding the specifics for your chosen provider is crucial for proper integration.

User
will this 
signin_url = 'http://127.0.0.1:8000/signin/'
            return redirect(signin_url) 
work?
ChatGPT
The line of code you provided:

python
Copy code
signin_url = 'http://127.0.0.1:8000/signin/'
return redirect(signin_url)
will redirect the user to the specified signin_url. However, there are a couple of considerations:

Cross-Origin Issues: If your projects are running on different ports (e.g., one on 8000 and the other on 8001), you might encounter cross-origin issues. Browsers may restrict redirects across different origins for security reasons. In a production environment, it's common to use a common domain or implement Cross-Origin Resource Sharing (CORS) to handle these scenarios.

Relative URLs: Instead of hardcoding the base URL, you might want to make the redirection more flexible by using relative URLs. Django provides the reverse function for this purpose. For example:

python
Copy code
from django.urls import reverse

signin_url = reverse('signin')  # 'signin' is the name of the URL pattern for your signin view
return redirect(signin_url)
This way, if you change the URL pattern for the signin view, you won't need to update the URL in multiple places.

OAuth Redirect URI: If you're integrating with OAuth 2.0, be sure that the redirect URI used for the authentication request (during the initial redirect to the sign-in project) is correctly registered with your OAuth 2.0 provider. The provider will redirect the user back to this URI after successful authentication.

Ensure that the considerations above align with your specific project setup and requirements. If you encounter issues, provide more details about your project structure, URLs, and any error messages you're encountering for more targeted assistance.

User
OAuth Redirect URI: If you're integrating with OAuth 2.0, be sure that the redirect URI used for the authentication request (during the initial redirect to the sign-in project) is correctly registered with your OAuth 2.0 provider. The provider will redirect the user back to this URI after successful authentication.

so in the demo project what should i write for redirect uri?
ChatGPT
The redirect URI in your demo project (the OAuth 2.0 client or relying party) should be set to the URL where you expect the OAuth 2.0 provider to redirect the user after successful authentication. This URL is often referred to as the OAuth 2.0 Redirect URI or Callback URL.

Assuming your demo project is running at http://127.0.0.1:8001/, you might set the redirect URI to something like:

bash
Copy code
http://127.0.0.1:8001/oauth2/callback/
Here are the steps to set up the redirect URI:

In Your Demo Project:

Determine the URL where you want the user to be redirected after successful authentication. This could be a specific endpoint, like /dashboard/ or /oauth2/callback/.
Register this URL as the redirect URI in your demo project.
In Your OAuth 2.0 Provider (Sign-In Project):

When initiating the OAuth 2.0 authentication request (e.g., during the initial redirect from the demo project to the sign-in project), include the registered redirect URI in the request.
For example, if you're using Django OAuth Toolkit in the sign-in project, you might have a configuration like this:

python
Copy code
# settings.py in the sign-in project
OAUTH2_PROVIDER = {
    'SCOPES': {'read': 'Read scope'},
    'ALLOWED_REDIRECT_URI_SCHEMES': ['http', 'https'],
}
Ensure that the redirect URI used in the OAuth 2.0 authentication request matches the one registered with your OAuth 2.0 provider. If they don't match, the provider may reject the request for security reasons.

Remember that the exact steps and configurations may vary depending on the OAuth 2.0 provider you are using, so refer to the provider's documentation for detailed instructions.







++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===================================================================================================================================
from django.urls import path
from .views import SignInView, ProtectedView

urlpatterns = [
    path('signin/', SignInView.as_view(), name='signin'),
    path('protected-view/', ProtectedView.as_view(), name='protected_view'),
    # Add other URLs as needed
]



# myapp/views.py

import requests
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.decorators import permission_classes, authentication_classes
from rest_framework.permissions import AllowAny
from rest_framework.authentication import SessionAuthentication, BasicAuthentication
from django.contrib.auth import authenticate, login
from django.http import JsonResponse
from oauth2_provider.models import AccessToken

class SignInView(APIView):
    permission_classes = [AllowAny]
    authentication_classes = [SessionAuthentication, BasicAuthentication]

    def post(self, request):
        client_id = 'your_client_id'
        client_secret = 'your_client_secret'
        username = request.data.get('username')
        password = request.data.get('password')

        existing_token = AccessToken.objects.filter(user__username=username).first()

        if existing_token and existing_token.is_valid():
            return JsonResponse({'access_token': existing_token.token, 'refresh_token': existing_token.user.refresh_token.token, 'user_id': existing_token.user.id, 'message': 'User already authenticated'})
        elif existing_token and existing_token.is_expired():
            new_access_token, new_refresh_token, user_id = self.refresh_access_token(existing_token.user.refresh_token.token, client_id, client_secret)

            user = authenticate(request, username=username, password=password)
            if user is not None:
                login(request, user)
                return JsonResponse({'access_token': new_access_token, 'refresh_token': new_refresh_token, 'user_id': user.id, 'message': 'Token refresh successful'})
        
        data = {
            'grant_type': 'password',
            'username': username,
            'password': password,
            'client_id': client_id,
            'client_secret': client_secret,
        }

        response = requests.post('http://localhost:8000/oauth2/token/', data=data)

        if response.status_code == 200:
            token_data = response.json()
            access_token = token_data.get('access_token')
            refresh_token = token_data.get('refresh_token')

            user = authenticate(request, username=username, password=password)
            if user is not None:
                login(request, user)
                return JsonResponse({'access_token': access_token, 'refresh_token': refresh_token, 'user_id': user.id, 'message': 'Sign-in successful'})
        else:
            return JsonResponse({'error': 'Invalid credentials'}, status=response.status_code)

    def refresh_access_token(self, refresh_token, client_id, client_secret):
        data = {
            'grant_type': 'refresh_token',
            'refresh_token': refresh_token,
            'client_id': client_id,
            'client_secret': client_secret,
        }

        response = requests.post('http://localhost:8000/oauth2/token/', data=data)

        if response.status_code == 200:
            token_data = response.json()
            new_access_token = token_data.get('access_token')
            new_refresh_token = token_data.get('refresh_token')
            user_id = token_data.get('user_id')  # Assuming the server provides the user ID in the response
            return new_access_token, new_refresh_token, user_id
        else:
            return None, None, None


class ProtectedView(APIView):
    authentication_classes = [SessionAuthentication, BasicAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        return Response({'message': f'Hello, {user.username}! This is a protected view.'})

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===========================================================================================================================

'oauth2_provider.middleware.OAuth2TokenMiddleware',


OAUTH2_PROVIDER = {
    'SCOPES': {'read': 'Read scope', 'write': 'Write scope'},
}

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
    ],
    # ... other settings
}
-------------------------------------------------------------------------------------------------------------------------------
from django.urls import path
from .views import *

urlpatterns = [
    path('signin/', signin, name='signin'),
    path('protected_view/', protected_view, name='protected_view'),
]


=================================================================================================================================

from rest_framework import status
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes,authentication_classes
from rest_framework.permissions import AllowAny
from django.contrib.auth import authenticate, login
from django.http import JsonResponse
import requests
from oauth2_provider.models import AccessToken
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

@api_view(['POST'])
@permission_classes([AllowAny])
def signin(request):
    # Assuming the client credentials are already registered in the Django Admin
    # You should replace 'your_client_id' and 'your_client_secret' with your actual client credentials
    client_id = 'nrvsopqC73obQxlXwRzVaZXeaPakf7uy6GHHTXmp'
    client_secret = 'uSJDRNaSmtkVgERpPAomw72QV0i0yhdGMggVKvF6T1yAeLMnOB4ZMr9qmFP0WOW5gXSx4UGauwUK8txm1nggvaQXoT7X6Gzftyve8buB5bgk84MM7dD0IdjeMEBNc8k7'
    email = request.data.get('email')
    password = request.data.get('password')


    existing_token = AccessToken.objects.filter(user__email=email).first()

    if existing_token and existing_token.is_valid():
        # If a valid token exists, use it
        return JsonResponse({'access_token': existing_token.token, 'user_id': existing_token.user.id, 'message': 'User already authenticated'})


    elif existing_token and existing_token.is_expired():
        # If the token is expired, refresh it
        new_access_token, new_refresh_token, user_id = refresh_access_token(existing_token.user.refresh_token.token, client_id, client_secret)
        return JsonResponse({'access_token': new_access_token, 'refresh_token': new_refresh_token, 'user_id': user_id, 'message': 'Token refresh successful'})



    data = {
        'grant_type': 'password',
        'username': 'admin@gmail.com',
        'password': 'a',
        'client_id': client_id,
        'client_secret': client_secret,
    }

    # Make a POST request to the OAuth2 token endpoint
    response = requests.post('http://localhost:8000/oauth2/token/', data=data)

    if response.status_code == 200:
        # Successfully authenticated, parse the response
        token_data = response.json()
        access_token = token_data.get('access_token')
        refresh_token = token_data.get('refresh_token')

        # Your logic after successful authentication
        user = authenticate(request, email=email, password=password)
        if user is not None:
            login(request, user)
            return JsonResponse({'access_token': access_token, 'refresh_token': refresh_token, 'user_id': user.id})
    else:
        # Authentication failed
        return JsonResponse({'error': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)


def refresh_access_token(refresh_token, client_id, client_secret):
    data = {
        'grant_type': 'refresh_token',
        'refresh_token': refresh_token,
        'client_id': client_id,
        'client_secret': client_secret,
    }

    # Make a POST request to the OAuth2 token refresh endpoint
    response = requests.post('http://localhost:8000/oauth2/token/', data=data)

    if response.status_code == 200:
        # Successfully refreshed, parse the response
        token_data = response.json()
        new_access_token = token_data.get('access_token')
        new_refresh_token = token_data.get('refresh_token')
        user_id = token_data.get('user_id')  # Assuming the server provides the user ID in the response
        return new_access_token, new_refresh_token, user_id
    else:
        # Token refresh failed
        return None, None, None


@api_view(['GET'])
@authentication_classes([OAuth2Authentication])
@permission_classes([IsAuthenticated])
def protected_view(request):
    user = request.user
    # Your logic for the protected view
    return Response({'message': f'Hello, {user.username}! This is a protected view.'})



==============================================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from .serializers import UserSerializer
from django.contrib.auth import get_user_model

class SignupAPIView(APIView):
    def post(self, request, *args, **kwargs):
        email = request.data.get('email')
        password = request.data.get('password')

        if not email or not password:
            return Response({'error': 'Both email and password are required.'}, status=status.HTTP_400_BAD_REQUEST)

        existing_user = get_user_model().objects.filter(email=email).first()

        if existing_user:
            return Response({'error': 'User with this email already exists.'}, status=status.HTTP_400_BAD_REQUEST)

        serializer = UserSerializer(data=request.data)

        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)












# management/commands/my_command.py

from django.core.management.base import BaseCommand
from first_app.models import Order  # Import the model from the first app
from second_app.models import Order2  # Import the model from the second app

class Command(BaseCommand):
    help = 'Copy specific data from Order model to Order2 model'

    def handle(self, *args, **options):
        # Retrieve data from the first database
        orders_from_first_database = Order.objects.filter(your_filtering_conditions_here)

        # Save specific data into the second database
        for order in orders_from_first_database:
            order2_instance = Order2(
                field1=order.field1,
                field2=order.field2,
                # Add other fields as needed
            )
            order2_instance.save()

        self.stdout.write(self.style.SUCCESS('Data copied successfully'))



------_-----------------------------

{
  "status": "not_yet_assigned",
  "assigned_to": "your_assigned_to_value",
  "order_numbers": ["order_number_1", "order_number_2", "order_number_3"]
}





# views.py

from rest_framework.generics import UpdateAPIView
from rest_framework.response import Response
from rest_framework import status

class OrdersPatchView(UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer

    def get_object(self):
        order_numbers = self.request.data.get('order_numbers', [])
        # Assuming you need a list of objects for multiple orders
        return Orders.objects.filter(order_number__in=order_numbers)

    def update(self, request, *args, **kwargs):
        instances = self.get_object()

        # Check if instances is None (orders not found)
        if not instances.exists():
            return Response({"error": "Invalid order_numbers."},
                            status=status.HTTP_404_NOT_FOUND)

        for instance in instances:
            serializer = self.get_serializer(instance, data=request.data, partial=True)
            serializer.is_valid(raise_exception=True)
            self.perform_update(serializer)

        return Response({"message": "Orders updated successfully."})





# serializers.py

class OrdersPatchSerializer(serializers.ModelSerializer):
    # ... (existing code)

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        status = validated_data.get('status', instance.status)
        order_numbers = validated_data.get('order_numbers', [])

        if status == 'manifest_pending':
            # ... (existing code)

        elif status == 'not_yet_assigned':
            # Update the assigned_to field for multiple orders
            assigned_to = validated_data.get('assigned_to')
            if assigned_to:
                instance.assigned_to = assigned_to
                instance.status = 'audit_in_progress'

        instance.save()
        return instance



# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import BarChart, Reference
from .models import YourModel
from datetime import datetime
import io
import os

def export_data_with_chart(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create bar chart using openpyxl
    chart = BarChart()
    values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    chart.add_data(values, titles_from_data=True)
    chart.set_categories(labels)
    chart.title = 'Data Chart'
    chart.x_axis.title = 'Date'
    chart.y_axis.title = 'Values'
    ws.add_chart(chart, 'E5')

    # Specify the local path to save the file
    local_file_path = '/path/to/your/local/directory/data_export_with_chart.xlsx'

    # Save Excel file locally
    wb.save(local_file_path)

    # Provide the file for download
    with open(local_file_path, 'rb') as local_file:
        response = HttpResponse(local_file.read(), content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        response['Content-Disposition'] = 'attachment; filename=data_export_with_chart.xlsx'

    return response

_------------------
radar_chart = RadarChart()
radar_values = Reference(ws, min_col=2, min_row=2, max_col=3, max_row=len(data) + 1)
radar_chart.add_data(radar_values, titles_from_data=True)
radar_chart.title = 'Data Radar Chart'
ws.add_chart(radar_chart, 'E95')

-----++++------
doughnut_chart = DoughnutChart()
doughnut_values = Reference(ws, min_col=2, min_row=2, max_col=2, max_row=len(data) + 1)
doughnut_chart.add_data(doughnut_values, titles_from_data=True)
doughnut_chart.title = 'Data Doughnut Chart'
ws.add_chart(doughnut_chart, 'E80')

--------------

area_chart = AreaChart()
area_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
area_chart.add_data(area_values, titles_from_data=True)
area_chart.title = 'Data Area Chart'
ws.add_chart(area_chart, 'E65')



____&&&______
scatter_chart = ScatterChart()
scatter_values = Reference(ws, min_col=2, min_row=2, max_col=3, max_row=len(data) + 1)
scatter_chart.add_data(scatter_values, titles_from_data=True)
scatter_chart.x_axis.title = 'X Values'
scatter_chart.y_axis.title = 'Y Values'
ws.add_chart(scatter_chart, 'E50')
--------------

# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import PieChart, Reference, BarChart, LineChart
from .models import YourModel
from datetime import datetime
import io

def export_data_with_charts(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create pie chart using openpyxl
    pie_chart = PieChart()
    data_points = Reference(ws, min_col=2, min_row=2, max_col=2, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    pie_chart.add_data(data_points, titles_from_data=True)
    pie_chart.set_categories(labels)
    pie_chart.title = 'Data Pie Chart'
    ws.add_chart(pie_chart, 'E5')

    # Create bar chart using openpyxl
    bar_chart = BarChart()
    bar_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    bar_labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    bar_chart.add_data(bar_values, titles_from_data=True)
    bar_chart.set_categories(bar_labels)
    bar_chart.title = 'Data Bar Chart'
    ws.add_chart(bar_chart, 'E20')

    # Create line chart using openpyxl
    line_chart = LineChart()
    line_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    line_labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    line_chart.add_data(line_values, titles_from_data=True)
    line_chart.set_categories(line_labels)
    line_chart.title = 'Data Line Chart'
    ws.add_chart(line_chart, 'E35')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export_with_charts.xlsx'
    wb.save(response)

    return response

---------------------

# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import BarChart, Reference
from .models import YourModel
from datetime import datetime
import io

def export_data_with_chart(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create bar chart using openpyxl
    chart = BarChart()
    values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    chart.add_data(values, titles_from_data=True)
    chart.set_categories(labels)
    chart.title = 'Data Chart'
    chart.x_axis.title = 'Date'
    chart.y_axis.title = 'Values'
    ws.add_chart(chart, 'E5')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export_with_chart.xlsx'
    wb.save(response)

    return response

------------------
# views.py
from django.http import HttpResponse
from django.shortcuts import render
import openpyxl
from .models import YourModel  # Import your model
from datetime import datetime

def export_data(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export.xlsx'
    wb.save(response)

    return response


------------+
# urls.py
from django.urls import path
from .views import generate_chart

urlpatterns = [
    path('generate-chart/', generate_chart, name='generate_chart'),
]

---------------
__________# views.py
from django.http import HttpResponse
from django.shortcuts import render
import openpyxl
from openpyxl.chart import BarChart, Reference
import matplotlib.pyplot as plt
import io

def generate_chart(request):
    # Your data retrieval logic here (replace this with your data)
    data = [
        ('Category 1', 10),
        ('Category 2', 20),
        ('Category 3', 15),
    ]

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.append(['Category', 'Value'])
    for row in data:
        ws.append(row)

    # Create bar chart using matplotlib
    plt.bar(range(2, len(data) + 2), [val[1] for val in data], tick_label=[val[0] for val in data])
    plt.title('Sample Chart')
    plt.xlabel('Categories')
    plt.ylabel('Values')

    # Save matplotlib chart to BytesIO buffer
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    plt.close()

    # Add chart image to Excel file
    chart_image = openpyxl.drawing.image.Image(buffer)
    ws.add_image(chart_image, 'D5')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=chart_example.xlsx'
    wb.save(response)

    return response

pip install openpyxl matplotlib

_-------+++##£££££&&&&&&&&&&&&--++++++-----
check_list = models.FileField(upload_to='uploads/', null=True, blank=True)
-----------------------------------------------------------------------------------------
# urls.py

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # ... your existing urlpatterns ...
]

# Serve media files during development
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

---------------------------------------------------------------------------------------------

# settings.py

# ...

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / "media"  # assuming BASE_DIR is the root directory of your Django project

# ...


--------------------------------------------------------------------------------------------------

class OrdersSerializer(serializers.ModelSerializer):
    class Meta:
        model = Orders
        fields = ('employee','order_number', 'tracking_number', 'borrowers_first_name', 'borrowers_last_name', 'additional_comments','check_received','check_received_amount','status')
    
    def create(self, validated_data):
        order_number = validated_data.get('order_number')
        validated_data['status'] = 'manifest_pending'
        validated_data['employee'] = validated_data.get('employee')
        existing_order = Orders.objects.filter(order_number=order_number).first()
        if existing_order:
            raise serializers.ValidationError({"order_number": ["Order with this order_number already exists."]})
        
        order = Orders.objects.create(**validated_data)
        return order


class OrdersPatchSerializer(serializers.ModelSerializer):

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date','loan_number', 'lender', 'state', 'county','zipcode','assigned_to','status','check_list','audit_status','audit_comment')

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        status = validated_data.get('status', instance.status)
        if status == 'manifest_pending':
            instance.entered_date = validated_data.get('entered_date', instance.entered_date)
            instance.closing_date = validated_data.get('closing_date', instance.closing_date)
            instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
            instance.loan_number = validated_data.get('loan_number', instance.loan_number)
            instance.lender = validated_data.get('lender', instance.lender)
            instance.state = validated_data.get('state', instance.state)
            instance.county = validated_data.get('county', instance.county)
            instance.zipcode = validated_data.get('zipcode', instance.zipcode)
            instance.status = 'not_yet_assigned'

        elif status == 'not_yet_assigned':
            # Update the assigned_to field
            assigned_to = validated_data.get('assigned_to')
            print(assigned_to)
            if assigned_to:
                instance.assigned_to = assigned_to
                instance.status = 'audit_in_progress'

        elif status == 'audit_in_progress':
            file_data = validated_data.get('check_list')

            if file_data:
                # Save the file in the 'media' folder
                with open(f'media/{file_data.name}', 'wb') as file:
                    for chunk in file_data.chunks():
                        file.write(chunk)

                # Update the 'check_list' field in the instance
                instance.check_list = file_data.name
                instance.audit_status = validated_data.get('audit_status', instance.audit_status)
                instance.audit_comment = validated_data.get('audit_comment', instance.audit_comment)
                if instance.audit_status == 'pass':
                    instance.status = 'audit_pass'
                else:
                    instance.status = 'audit_fail'

        else:
            raise serializers.ValidationError(f"Invalid status: {status}.")
        
        instance.save()
        return instance

---------------------------------------------------------------------------------------------------------
# admin.py
from django.contrib import admin
from import_export.admin import ImportExportModelAdmin
from .models import State, County
from .resources import StateResource, CountyResource

@admin.register(State)
class StateAdmin(ImportExportModelAdmin):
    resource_class = StateResource

@admin.register(County)
class CountyAdmin(ImportExportModelAdmin):
    resource_class = CountyResource


-------------------------------------------------------------------------------------------------------------------------
# resources.py
from import_export import resources, fields
from import_export.widgets import ForeignKeyWidget
from .models import State, County

class StateResource(resources.ModelResource):
    class Meta:
        model = State
        fields = ('state_id', 'state_name')
        import_id_fields = ('state_id',)

class CountyResource(resources.ModelResource):
    state = fields.Field(
        column_name='state_id',
        attribute='state',
        widget=ForeignKeyWidget(State, 'state_id')
    )

    class Meta:
        model = County
        fields = ('county_id', 'county_name', 'state')
        import_id_fields = ('county_id',)

-------------------------------------------------------------------------------------------------------

# models.py
from django.db import models

class State(models.Model):
    state_id = models.AutoField(primary_key=True)
    state_name = models.CharField(max_length=255)

class County(models.Model):
    county_id = models.AutoField(primary_key=True)
    county_name = models.CharField(max_length=255)
    state = models.ForeignKey(State, on_delete=models.CASCADE)


------------------------------------------------------------------------------------------------------------
INSTALLED_APPS = [
    # ...
    'import_export',
    # ...
]

-------------------------------------------------------------------------------------------------------------
pip install django-import-export

--------------------------------------------------------------------------------------------------------------------
# views.py
from rest_framework.response import Response
from rest_framework import status

class OrdersPatchView(generics.UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer
    lookup_field = 'order_number'  # Assuming 'order_number' is part of the URL kwargs

    def get_object(self):
        order_number = self.kwargs.get(self.lookup_field)
        status = self.kwargs.get('status')  # Assuming 'status' is part of the URL kwargs

        # Add additional condition based on the 'status'
        if status == 'manifest_pending':
            return self.queryset.get(order_number=order_number, status='manifest pending')
        elif status == 'not_yet_assigned':
            return self.queryset.get(order_number=order_number, status='not yet assigned')
        else:
            # Return None or raise a 404 depending on your use case
            return None

    def update(self, request, *args, **kwargs):
        instance = self.get_object()

        # Check if instance is None (order not found or invalid status)
        if instance is None:
            return Response({"error": "Invalid order_number or status."},
                            status=status.HTTP_404_NOT_FOUND)

        serializer = self.get_serializer(instance, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        return Response(serializer.data)

-------------------------------------------------------------------------------------------------------------------------------
# serializers.py

class OrdersPatchSerializer(serializers.ModelSerializer):

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date', 'loan_number', 'lender', 'state', 'county', 'zipcode', 'status', 'assigned_to')

    def update(self, instance, validated_data):
        # Check the status and update the assigned_to field if needed
        status = validated_data.get('status', instance.status)
        if status == 'manifest pending':
            # Update the main Orders model fields
            instance.entered_date = validated_data.get('entered_date', instance.entered_date)
            instance.closing_date = validated_data.get('closing_date', instance.closing_date)
            instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
            instance.loan_number = validated_data.get('loan_number', instance.loan_number)
            instance.lender = validated_data.get('lender', instance.lender)
            instance.state = validated_data.get('state', instance.state)
            instance.county = validated_data.get('county', instance.county)
            instance.zipcode = validated_data.get('zipcode', instance.zipcode)
        elif status == 'not yet assigned':
            # Update the assigned_to field
            assigned_to = validated_data.get('assigned_to')
            if assigned_to:
                instance.assigned_to = assigned_to
        else:
            raise serializers.ValidationError(f"Invalid status: {status}.")

        instance.save()
        return instance


----------------------------------------------------------------------------------------------------------------------------
models.py
from django.db import models
from django.contrib.auth.models import AbstractUser
from django.db import models
from .managers import *

class CustomUser(AbstractUser):
    username = None
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15, blank=True, null=True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    objects = CustomUserManager()

    def __str__(self):
        return self.email


class Orders(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    order_number = models.CharField(max_length=255)
    tracking_number = models.CharField(max_length=255)
    borrowers_first_name = models.CharField(max_length=255)
    borrowers_last_name = models.CharField(max_length=255)
    additional_comments = models.TextField()
    file_url = models.URLField()
    entered_date = models.DateTimeField(null=True, blank=True)
    closing_date = models.DateTimeField(null=True, blank=True)
    disbursment_date = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    zipcode = models.CharField(max_length=10)

class Check(models.Model):
    CHECK_RECEIVED_CHOICES = [
        ('yes', 'Yes'),
        ('no', 'No'),
        ('missing', 'Missing'),
    ]
    order = models.ForeignKey(Orders, on_delete=models.CASCADE,related_name='checks')
    check_received = models.CharField(choices=CHECK_RECEIVED_CHOICES, max_length=10)
    check_received_amount = models.IntegerField(null=True, blank=True)

class Lender(models.Model):
    LENDER_CHOICES = [
        ('affinity', 'Affinity'),
        ('boa', 'Bank of America'),
        ('boa_heloc', 'Bank of America HELOC'),
        # Add other choices
    ]
    order = models.OneToOneField(Orders, on_delete=models.CASCADE)
    lender_type = models.CharField(choices=LENDER_CHOICES, max_length=20)

class State(models.Model):
    STATE_CHOICES = [
        ('jharkhand', 'Jharkhand'),
        ('bihar', 'Bihar'),
        # Add other choices
    ]
    order = models.OneToOneField(Orders, on_delete=models.CASCADE)
    state_type = models.CharField(choices=STATE_CHOICES, max_length=20)

class County(models.Model):
    COUNTY_CHOICES = [
        ('ranchi', 'Ranchi'),
        ('jamshedpur', 'Jamshedpur'),
        # Add other choices
    ]
    state = models.ForeignKey(State, on_delete=models.CASCADE)
    county_type = models.CharField(choices=COUNTY_CHOICES, max_length=20)
--------------------------------------------------------------------------------------------

managers.py
# customuser/managers.py
from django.contrib.auth.models import BaseUserManager

class CustomUserManager(BaseUserManager):
    def create_user(self, email, phone_number=None, password=None, **extra_fields):
        if not email:
            raise ValueError('The Email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, phone_number=phone_number, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        return self.create_user(email, password, **extra_fields)
--------------------------------------------------------------------------------------------------

serializers.py

from rest_framework import serializers
from .models import *

class CustomUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = '__all__'

class CheckListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Check
        fields = '__all__'

        
class OrdersListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Orders
        fields = '__all__'

class CustomUserCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ('email', 'phone_number', 'password')
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        user = CustomUser.objects.create_user(**validated_data)
        return user


class CheckSerializer(serializers.ModelSerializer):
    class Meta:
        model = Check
        fields = ('check_received', 'check_received_amount')

    def validate(self, data):
        check_received = data.get('check_received')
        check_received_amount = data.get('check_received_amount')

        if check_received == 'yes' and not check_received_amount:
            raise serializers.ValidationError("check_received_amount is required when check_received is 'yes'.")

        return data

class OrdersSerializer(serializers.ModelSerializer):
    check = CheckSerializer(many=True)
    user = 1
    class Meta:
        model = Orders
        fields = ('user','order_number', 'tracking_number', 'borrowers_first_name', 'borrowers_last_name', 'additional_comments', 'check')
    
    def create(self, validated_data):
        check_data = validated_data.pop('check',None)
        order_number = validated_data.get('order_number')
        validated_data['user'] = validated_data.get('user')
        existing_order = Orders.objects.filter(order_number=order_number).first()
        if existing_order:
            raise serializers.ValidationError({"order_number": ["Order with this order_number already exists."]})
        
        order = Orders.objects.create(**validated_data)
        if check_data:
            for check_data in check_data:
                Check.objects.create(order=order, **check_data)
        return order

---------------------------------------------------------------------
views.py
from rest_framework import generics
from rest_framework.response import Response
from rest_framework import status
from django.db.models import Prefetch

from .models import *
from .serializers import *

class CustomUserListView(generics.ListAPIView):
    queryset = CustomUser.objects.all()
    serializer_class = CustomUserSerializer

class CustomUserCreateView(generics.CreateAPIView):
    queryset = CustomUser.objects.all()
    serializer_class = CustomUserCreateSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)


class OrdersListView(generics.ListAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersListSerializer

    def get_queryset(self):
        # Customize the queryset to include related Check data
        return Orders.objects.prefetch_related('checks').all()

    def get_check_data(self, order_id):
        # Your logic to get Check data for a specific order
        checks = Check.objects.filter(order_id=order_id).values('check_received', 'check_received_amount')
        checks_list = list(checks)
        return checks_list

    def list(self, request, *args, **kwargs):
        # Override the list method to customize serialized data
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        print(serializer)
        # Customize serialized data to include Check details
        for order_data in serializer.data:
            print(order_data)
            order_id = order_data['id']
            check_data = self.get_check_data(order_id)
            order_data['check'] = check_data

        return Response(serializer.data)

class OrdersCreateView(generics.CreateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersSerializer
---------------------------------------------------------------------------------


urls.py

from django.urls import path
from .views import *

urlpatterns = [
    path('users/', CustomUserListView.as_view(), name='user-list'),
    path('users/create/', CustomUserCreateView.as_view(), name='user-create'),
    path('orders/create/', OrdersCreateView.as_view(), name='create-order'),
    path('orders/list/', OrdersListView.as_view(), name='order-list'),
]



-------------------------------------------------------------------------------------------------------------------------------------------------------------

# serializers.py
from rest_framework import serializers
from .models import Orders, Lender, State, County

class LenderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Lender
        fields = ('lender_type',)

class StateSerializer(serializers.ModelSerializer):
    class Meta:
        model = State
        fields = ('state_type',)

class CountySerializer(serializers.ModelSerializer):
    class Meta:
        model = County
        fields = ('county_type',)

class OrdersPatchSerializer(serializers.ModelSerializer):
    lender = LenderSerializer(required=False)
    state = StateSerializer(required=False)
    county = CountySerializer(required=False)

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date', 'lender', 'state', 'county')

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        instance.entered_date = validated_data.get('entered_date', instance.entered_date)
        instance.closing_date = validated_data.get('closing_date', instance.closing_date)
        instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
        instance.save()

        # Update the related Lender, State, County models
        lender_data = validated_data.get('lender')
        state_data = validated_data.get('state')
        county_data = validated_data.get('county')

        if lender_data:
            lender, created = Lender.objects.get_or_create(order=instance)
            lender.lender_type = lender_data.get('lender_type')
            lender.save()

        if state_data:
            state, created = State.objects.get_or_create(order=instance)
            state.state_type = state_data.get('state_type')
            state.save()

        if county_data:
            county, created = County.objects.get_or_create(state=state)
            county.county_type = county_data.get('county_type')
            county.save()

        return instance

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
# views.py
from rest_framework import generics
from .models import Orders
from .serializers import OrdersPatchSerializer

class OrdersPatchView(generics.UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer
    lookup_field = 'order_number'  # Assuming order_number is unique

    def get_object(self):
        order_number = self.kwargs.get(self.lookup_field)
        return self.queryset.get(order_number=order_number)


-------------------------------------------------------------------------------------------------------------
# urls.py
from django.urls import path
from .views import OrdersPatchView

urlpatterns = [
    path('orders/<str:order_number>/', OrdersPatchView.as_view(), name='orders-patch'),
    # Add other URL patterns as needed
]


-->

<html>
  <body>
    <h1> hey </h1>
  </body>
</html>





<!-- 


tests.py

# myapp/tests.py
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from .models import CustomUser, Orders, Employee, Check

class CustomUserTests(TestCase):
    def test_create_user(self):
        response = self.client.post('/api/users/create/', {
            'email': 'test@example.com',
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(CustomUser.objects.count(), 1)
        user = CustomUser.objects.get()
        self.assertEqual(user.email, 'test@example.com')

class OrdersTests(APITestCase):
    def setUp(self):
        # Create a user for testing
        self.user = CustomUser.objects.create(email='test@example.com', password='testpassword')
        # Create an employee for testing
        self.employee = Employee.objects.create(user=self.user, employee_id='123', designation='Test', process='Test', branch='Test', reporting_to=self.user)
        
    def test_create_order(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Orders.objects.count(), 1)
        order = Orders.objects.get()
        self.assertEqual(order.order_number, '123456')

    def test_list_orders(self):
        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)  # Assuming no orders in the test database

    # Add more tests as needed for other APIs


--------------------------------------------------------------------------------------------------------

# myapp/tests.py
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from .models import CustomUser, Orders, Employee, Check

class CustomUserTests(APITestCase):
    def test_create_user(self):
        response = self.client.post('/api/users/create/', {
            'email': 'test@example.com',
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(CustomUser.objects.count(), 1)
        user = CustomUser.objects.get()
        self.assertEqual(user.email, 'test@example.com')

    def test_create_user_invalid_data(self):
        response = self.client.post('/api/users/create/', {
            'email': 'invalidemail',  # Invalid email format
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(CustomUser.objects.count(), 0)

class OrdersTests(APITestCase):
    def setUp(self):
        self.user = CustomUser.objects.create(email='test@example.com', password='testpassword')
        self.employee = Employee.objects.create(user=self.user, employee_id='123', designation='Test', process='Test', branch='Test', reporting_to=self.user)
        
    def test_create_order(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Orders.objects.count(), 1)
        order = Orders.objects.get()
        self.assertEqual(order.order_number, '123456')

    def test_create_order_invalid_data(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': 'invalid_order',  # Invalid order_number format
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(Orders.objects.count(), 0)

    def test_list_orders(self):
        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)  # Assuming no orders in the test database

    # Add more tests as needed for other APIs
------------------------------------------------------------------------------------------------------------------------------
# myapp/tests.py
# ...

class OrdersTests(APITestCase):
    # ... (previous test cases)

    def test_create_order_unauthenticated(self):
        # Ensure creating an order without authentication returns 401 Unauthorized
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(Orders.objects.count(), 0)

    def test_list_orders_with_checks(self):
        # Ensure listing orders also includes check details
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        Check.objects.create(order=order, check_received='yes', check_received_amount=500)
        Check.objects.create(order=order, check_received='yes', check_received_amount=600)

        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(len(response.data[0]['check']), 2)

    def test_patch_order_manifest_pending(self):
        # Ensure patching an order with 'manifest pending' status updates fields
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        self.client.force_authenticate(self.user)
        response = self.client.patch(f'/api/orders/{order.order_number}/', {
            'status': 'manifest pending',
            'entered_date': '2023-01-01',
            'closing_date': '2023-02-01',
            'disbursment_date': '2023-03-01',
            'loan_number': 12345,
            'lender': 'Test Lender',
            'state': 'California',
            'county': 'Los Angeles',
            'zipcode': '90001'
        })

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        updated_order = Orders.objects.get(pk=order.pk)
        self.assertEqual(updated_order.entered_date, '2023-01-01')
        self.assertEqual(updated_order.closing_date, '2023-02-01')
        self.assertEqual(updated_order.disbursment_date, '2023-03-01')
        self.assertEqual(updated_order.loan_number, 12345)
        self.assertEqual(updated_order.lender, 'Test Lender')
        self.assertEqual(updated_order.state, 'California')
        self.assertEqual(updated_order.county, 'Los Angeles')
        self.assertEqual(updated_order.zipcode, '90001')

    def test_patch_order_not_assigned(self):
        # Ensure patching an order with 'not yet assigned' status updates 'assigned_to'
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        self.client.force_authenticate(self.user)
        response = self.client.patch(f'/api/orders/{order.order_number}/', {
            'status': 'not yet assigned',
            'assigned_to': 'new_assignee@example.com'
        })

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        updated_order = Orders.objects.get(pk=order.pk)
        self.assertEqual(updated_order.assigned_to, 'new_assignee@example.com')

    # Add more test cases as needed for other scenarios
----------------------------------------------------------------------------------------------------------------------

python manage.py test myapp.tests

----------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++=============================-----------------------------------------------------------


# project_graphql/schema.py
import graphene
from graphene_django.types import DjangoObjectType
from .models import Order
import requests

class OrderType(DjangoObjectType):
    class Meta:
        model = Order

class Query(graphene.ObjectType):
    all_orders = graphene.List(OrderType)

    def resolve_all_orders(self, info):
        return Order.objects.all()

class FetchAndSaveOrdersMutation(graphene.Mutation):
    class Arguments:
        api_url = graphene.String(required=True)
        params = graphene.JSONString(required=True)  # JSON string representing parameters to send to the API

    success = graphene.Boolean()

    def mutate(self, info, api_url, params):
        try:
            # Make a request to the specified API URL with the provided parameters
            response = requests.get(api_url, params=params)
            response.raise_for_status()  # Raise an error for HTTP errors

            # Parse the JSON response assuming it is in the expected format
            data = response.json()

            # Update the Order model based on the fetched data
            for order_data in data:
                Order.objects.create(
                    order_id=order_data.get('order_id'),
                    tracking_number=order_data.get('tracking_number'),
                    borrowers_first_name=order_data.get('borrowers_first_name'),
                    borrowers_last_name=order_data.get('borrowers_last_name'),
                    additional_comments=order_data.get('additional_comments'),
                    # Add other fields as needed
                )

            success = True  # Set to True if the operation is successful
        except Exception as e:
            print(f"Error fetching and saving Orders: {str(e)}")
            success = False

        return FetchAndSaveOrdersMutation(success=success)

class Mutation(graphene.ObjectType):
    fetch_and_save_orders = FetchAndSaveOrdersMutation.Field()

schema = graphene.Schema(query=Query, mutation=Mutation)


----------------------------------------------------------------------------------------------------------------------------------------
mutation {
  fetch_and_save_orders(api_url: "http://example.com/api/orders", params: "{\"status\": \"shipped\", \"limit\": 10}") {
    success
  }
}
-------------------------------------------------------------------------------------------------

mutation {
  fetch_and_save_orders(api_url: "http://example.com/api/orders", ids: [1, 2, 3]) {
    success
  }
}
------------------------##############################################################################---------------------------------------------------------------------

// EditOrder.js
import React, { useState } from 'react';
import { useMutation } from '@apollo/client';
import gql from 'graphql-tag';

const EDIT_ORDER = gql`
  mutation EditOrder($api_url: String!, $params: String!) {
    fetch_and_save_orders(api_url: $api_url, params: $params) {
      success
    }
  }
`;

const EditOrder = ({ orderId, currentAmount }) => {
  const [newAmount, setNewAmount] = useState(currentAmount);

  const [editOrder] = useMutation(EDIT_ORDER);

  const handleEdit = () => {
    // Prepare the parameters for the API request
    const params = JSON.stringify({
      id: orderId,
      amount: newAmount,
      // Add other parameters as needed
    });

    // Define the API URL
    const apiUrl = 'http://example.com/api/edit_order';

    // Make the mutation request
    editOrder({
      variables: {
        api_url: apiUrl,
        params: params,
      },
    })
      .then((response) => {
        // Handle the response if needed
        console.log(response);
      })
      .catch((error) => {
        // Handle errors
        console.error(error);
      });
  };

  return (
    <div>
      <label htmlFor="newAmount">New Amount:</label>
      <input
        type="number"
        id="newAmount"
        value={newAmount}
        onChange={(e) => setNewAmount(e.target.value)}
      />
      <button onClick={handleEdit}>Edit Order</button>
    </div>
  );
};

export default EditOrder;
-----------------------------------------------------------------#################################################################-------------------------------------------

// App.js
import React from 'react';
import { ApolloProvider, ApolloClient, InMemoryCache } from '@apollo/client';
import EditOrder from './EditOrder';

// Define your GraphQL endpoint
const uri = 'http://localhost:8000/graphql/';

const client = new ApolloClient({
  uri,
  cache: new InMemoryCache(),
});

const orders = [
  // Sample order data
  { id: 1, amount: 100 },
  { id: 2, amount: 150 },
  // Add more orders as needed
];

const App = () => {
  return (
    <ApolloProvider client={client}>
      <div>
        {orders.map((order) => (
          <div key={order.id}>
            <p>Order ID: {order.id}</p>
            <p>Amount: {order.amount}</p>
            <EditOrder orderId={order.id} currentAmount={order.amount} />
            <hr />
          </div>
        ))}
      </div>
    </ApolloProvider>
  );
};

export default App;






-->
