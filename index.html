<!--



{
  "status": "not_yet_assigned",
  "assigned_to": "your_assigned_to_value",
  "order_numbers": ["order_number_1", "order_number_2", "order_number_3"]
}





# views.py

from rest_framework.generics import UpdateAPIView
from rest_framework.response import Response
from rest_framework import status

class OrdersPatchView(UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer

    def get_object(self):
        order_numbers = self.request.data.get('order_numbers', [])
        # Assuming you need a list of objects for multiple orders
        return Orders.objects.filter(order_number__in=order_numbers)

    def update(self, request, *args, **kwargs):
        instances = self.get_object()

        # Check if instances is None (orders not found)
        if not instances.exists():
            return Response({"error": "Invalid order_numbers."},
                            status=status.HTTP_404_NOT_FOUND)

        for instance in instances:
            serializer = self.get_serializer(instance, data=request.data, partial=True)
            serializer.is_valid(raise_exception=True)
            self.perform_update(serializer)

        return Response({"message": "Orders updated successfully."})





# serializers.py

class OrdersPatchSerializer(serializers.ModelSerializer):
    # ... (existing code)

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        status = validated_data.get('status', instance.status)
        order_numbers = validated_data.get('order_numbers', [])

        if status == 'manifest_pending':
            # ... (existing code)

        elif status == 'not_yet_assigned':
            # Update the assigned_to field for multiple orders
            assigned_to = validated_data.get('assigned_to')
            if assigned_to:
                instance.assigned_to = assigned_to
                instance.status = 'audit_in_progress'

        instance.save()
        return instance



# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import BarChart, Reference
from .models import YourModel
from datetime import datetime
import io
import os

def export_data_with_chart(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create bar chart using openpyxl
    chart = BarChart()
    values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    chart.add_data(values, titles_from_data=True)
    chart.set_categories(labels)
    chart.title = 'Data Chart'
    chart.x_axis.title = 'Date'
    chart.y_axis.title = 'Values'
    ws.add_chart(chart, 'E5')

    # Specify the local path to save the file
    local_file_path = '/path/to/your/local/directory/data_export_with_chart.xlsx'

    # Save Excel file locally
    wb.save(local_file_path)

    # Provide the file for download
    with open(local_file_path, 'rb') as local_file:
        response = HttpResponse(local_file.read(), content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        response['Content-Disposition'] = 'attachment; filename=data_export_with_chart.xlsx'

    return response

_------------------
radar_chart = RadarChart()
radar_values = Reference(ws, min_col=2, min_row=2, max_col=3, max_row=len(data) + 1)
radar_chart.add_data(radar_values, titles_from_data=True)
radar_chart.title = 'Data Radar Chart'
ws.add_chart(radar_chart, 'E95')

-----++++------
doughnut_chart = DoughnutChart()
doughnut_values = Reference(ws, min_col=2, min_row=2, max_col=2, max_row=len(data) + 1)
doughnut_chart.add_data(doughnut_values, titles_from_data=True)
doughnut_chart.title = 'Data Doughnut Chart'
ws.add_chart(doughnut_chart, 'E80')

--------------

area_chart = AreaChart()
area_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
area_chart.add_data(area_values, titles_from_data=True)
area_chart.title = 'Data Area Chart'
ws.add_chart(area_chart, 'E65')



____&&&______
scatter_chart = ScatterChart()
scatter_values = Reference(ws, min_col=2, min_row=2, max_col=3, max_row=len(data) + 1)
scatter_chart.add_data(scatter_values, titles_from_data=True)
scatter_chart.x_axis.title = 'X Values'
scatter_chart.y_axis.title = 'Y Values'
ws.add_chart(scatter_chart, 'E50')
--------------

# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import PieChart, Reference, BarChart, LineChart
from .models import YourModel
from datetime import datetime
import io

def export_data_with_charts(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create pie chart using openpyxl
    pie_chart = PieChart()
    data_points = Reference(ws, min_col=2, min_row=2, max_col=2, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    pie_chart.add_data(data_points, titles_from_data=True)
    pie_chart.set_categories(labels)
    pie_chart.title = 'Data Pie Chart'
    ws.add_chart(pie_chart, 'E5')

    # Create bar chart using openpyxl
    bar_chart = BarChart()
    bar_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    bar_labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    bar_chart.add_data(bar_values, titles_from_data=True)
    bar_chart.set_categories(bar_labels)
    bar_chart.title = 'Data Bar Chart'
    ws.add_chart(bar_chart, 'E20')

    # Create line chart using openpyxl
    line_chart = LineChart()
    line_values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    line_labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    line_chart.add_data(line_values, titles_from_data=True)
    line_chart.set_categories(line_labels)
    line_chart.title = 'Data Line Chart'
    ws.add_chart(line_chart, 'E35')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export_with_charts.xlsx'
    wb.save(response)

    return response

---------------------

# views.py
from django.http import HttpResponse
import openpyxl
from openpyxl.chart import BarChart, Reference
from .models import YourModel
from datetime import datetime
import io

def export_data_with_chart(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Create bar chart using openpyxl
    chart = BarChart()
    values = Reference(ws, min_col=2, min_row=2, max_col=4, max_row=len(data) + 1)
    labels = Reference(ws, min_col=1, min_row=2, max_row=len(data) + 1)
    chart.add_data(values, titles_from_data=True)
    chart.set_categories(labels)
    chart.title = 'Data Chart'
    chart.x_axis.title = 'Date'
    chart.y_axis.title = 'Values'
    ws.add_chart(chart, 'E5')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export_with_chart.xlsx'
    wb.save(response)

    return response

------------------
# views.py
from django.http import HttpResponse
from django.shortcuts import render
import openpyxl
from .models import YourModel  # Import your model
from datetime import datetime

def export_data(request):
    # Replace 'YourModel' and 'date_field' with your actual model and date field
    data = YourModel.objects.filter(date_field__gte=datetime(2023, 1, 1))  # Filter by date

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = 'Data Sheet'

    # Add headers
    headers = ['Field1', 'Field2', 'Date']  # Replace with your actual field names
    ws.append(headers)

    # Add data rows
    for row in data:
        ws.append([row.field1, row.field2, row.date_field])  # Replace with your actual field names

    # Set column widths (optional)
    for col_num, header in enumerate(headers, 1):
        col_letter = openpyxl.utils.get_column_letter(col_num)
        max_length = max(len(str(cell.value)) for cell in ws[col_letter])
        adjusted_width = (max_length + 2)
        ws.column_dimensions[col_letter].width = adjusted_width

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=data_export.xlsx'
    wb.save(response)

    return response


------------+
# urls.py
from django.urls import path
from .views import generate_chart

urlpatterns = [
    path('generate-chart/', generate_chart, name='generate_chart'),
]

---------------
__________# views.py
from django.http import HttpResponse
from django.shortcuts import render
import openpyxl
from openpyxl.chart import BarChart, Reference
import matplotlib.pyplot as plt
import io

def generate_chart(request):
    # Your data retrieval logic here (replace this with your data)
    data = [
        ('Category 1', 10),
        ('Category 2', 20),
        ('Category 3', 15),
    ]

    # Create Excel workbook and add data
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.append(['Category', 'Value'])
    for row in data:
        ws.append(row)

    # Create bar chart using matplotlib
    plt.bar(range(2, len(data) + 2), [val[1] for val in data], tick_label=[val[0] for val in data])
    plt.title('Sample Chart')
    plt.xlabel('Categories')
    plt.ylabel('Values')

    # Save matplotlib chart to BytesIO buffer
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    plt.close()

    # Add chart image to Excel file
    chart_image = openpyxl.drawing.image.Image(buffer)
    ws.add_image(chart_image, 'D5')

    # Save Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=chart_example.xlsx'
    wb.save(response)

    return response

pip install openpyxl matplotlib

_-------+++##£££££&&&&&&&&&&&&--++++++-----
check_list = models.FileField(upload_to='uploads/', null=True, blank=True)
-----------------------------------------------------------------------------------------
# urls.py

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # ... your existing urlpatterns ...
]

# Serve media files during development
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

---------------------------------------------------------------------------------------------

# settings.py

# ...

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / "media"  # assuming BASE_DIR is the root directory of your Django project

# ...


--------------------------------------------------------------------------------------------------

class OrdersSerializer(serializers.ModelSerializer):
    class Meta:
        model = Orders
        fields = ('employee','order_number', 'tracking_number', 'borrowers_first_name', 'borrowers_last_name', 'additional_comments','check_received','check_received_amount','status')
    
    def create(self, validated_data):
        order_number = validated_data.get('order_number')
        validated_data['status'] = 'manifest_pending'
        validated_data['employee'] = validated_data.get('employee')
        existing_order = Orders.objects.filter(order_number=order_number).first()
        if existing_order:
            raise serializers.ValidationError({"order_number": ["Order with this order_number already exists."]})
        
        order = Orders.objects.create(**validated_data)
        return order


class OrdersPatchSerializer(serializers.ModelSerializer):

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date','loan_number', 'lender', 'state', 'county','zipcode','assigned_to','status','check_list','audit_status','audit_comment')

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        status = validated_data.get('status', instance.status)
        if status == 'manifest_pending':
            instance.entered_date = validated_data.get('entered_date', instance.entered_date)
            instance.closing_date = validated_data.get('closing_date', instance.closing_date)
            instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
            instance.loan_number = validated_data.get('loan_number', instance.loan_number)
            instance.lender = validated_data.get('lender', instance.lender)
            instance.state = validated_data.get('state', instance.state)
            instance.county = validated_data.get('county', instance.county)
            instance.zipcode = validated_data.get('zipcode', instance.zipcode)
            instance.status = 'not_yet_assigned'

        elif status == 'not_yet_assigned':
            # Update the assigned_to field
            assigned_to = validated_data.get('assigned_to')
            print(assigned_to)
            if assigned_to:
                instance.assigned_to = assigned_to
                instance.status = 'audit_in_progress'

        elif status == 'audit_in_progress':
            file_data = validated_data.get('check_list')

            if file_data:
                # Save the file in the 'media' folder
                with open(f'media/{file_data.name}', 'wb') as file:
                    for chunk in file_data.chunks():
                        file.write(chunk)

                # Update the 'check_list' field in the instance
                instance.check_list = file_data.name
                instance.audit_status = validated_data.get('audit_status', instance.audit_status)
                instance.audit_comment = validated_data.get('audit_comment', instance.audit_comment)
                if instance.audit_status == 'pass':
                    instance.status = 'audit_pass'
                else:
                    instance.status = 'audit_fail'

        else:
            raise serializers.ValidationError(f"Invalid status: {status}.")
        
        instance.save()
        return instance

---------------------------------------------------------------------------------------------------------
# admin.py
from django.contrib import admin
from import_export.admin import ImportExportModelAdmin
from .models import State, County
from .resources import StateResource, CountyResource

@admin.register(State)
class StateAdmin(ImportExportModelAdmin):
    resource_class = StateResource

@admin.register(County)
class CountyAdmin(ImportExportModelAdmin):
    resource_class = CountyResource


-------------------------------------------------------------------------------------------------------------------------
# resources.py
from import_export import resources, fields
from import_export.widgets import ForeignKeyWidget
from .models import State, County

class StateResource(resources.ModelResource):
    class Meta:
        model = State
        fields = ('state_id', 'state_name')
        import_id_fields = ('state_id',)

class CountyResource(resources.ModelResource):
    state = fields.Field(
        column_name='state_id',
        attribute='state',
        widget=ForeignKeyWidget(State, 'state_id')
    )

    class Meta:
        model = County
        fields = ('county_id', 'county_name', 'state')
        import_id_fields = ('county_id',)

-------------------------------------------------------------------------------------------------------

# models.py
from django.db import models

class State(models.Model):
    state_id = models.AutoField(primary_key=True)
    state_name = models.CharField(max_length=255)

class County(models.Model):
    county_id = models.AutoField(primary_key=True)
    county_name = models.CharField(max_length=255)
    state = models.ForeignKey(State, on_delete=models.CASCADE)


------------------------------------------------------------------------------------------------------------
INSTALLED_APPS = [
    # ...
    'import_export',
    # ...
]

-------------------------------------------------------------------------------------------------------------
pip install django-import-export

--------------------------------------------------------------------------------------------------------------------
# views.py
from rest_framework.response import Response
from rest_framework import status

class OrdersPatchView(generics.UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer
    lookup_field = 'order_number'  # Assuming 'order_number' is part of the URL kwargs

    def get_object(self):
        order_number = self.kwargs.get(self.lookup_field)
        status = self.kwargs.get('status')  # Assuming 'status' is part of the URL kwargs

        # Add additional condition based on the 'status'
        if status == 'manifest_pending':
            return self.queryset.get(order_number=order_number, status='manifest pending')
        elif status == 'not_yet_assigned':
            return self.queryset.get(order_number=order_number, status='not yet assigned')
        else:
            # Return None or raise a 404 depending on your use case
            return None

    def update(self, request, *args, **kwargs):
        instance = self.get_object()

        # Check if instance is None (order not found or invalid status)
        if instance is None:
            return Response({"error": "Invalid order_number or status."},
                            status=status.HTTP_404_NOT_FOUND)

        serializer = self.get_serializer(instance, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        return Response(serializer.data)

-------------------------------------------------------------------------------------------------------------------------------
# serializers.py

class OrdersPatchSerializer(serializers.ModelSerializer):

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date', 'loan_number', 'lender', 'state', 'county', 'zipcode', 'status', 'assigned_to')

    def update(self, instance, validated_data):
        # Check the status and update the assigned_to field if needed
        status = validated_data.get('status', instance.status)
        if status == 'manifest pending':
            # Update the main Orders model fields
            instance.entered_date = validated_data.get('entered_date', instance.entered_date)
            instance.closing_date = validated_data.get('closing_date', instance.closing_date)
            instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
            instance.loan_number = validated_data.get('loan_number', instance.loan_number)
            instance.lender = validated_data.get('lender', instance.lender)
            instance.state = validated_data.get('state', instance.state)
            instance.county = validated_data.get('county', instance.county)
            instance.zipcode = validated_data.get('zipcode', instance.zipcode)
        elif status == 'not yet assigned':
            # Update the assigned_to field
            assigned_to = validated_data.get('assigned_to')
            if assigned_to:
                instance.assigned_to = assigned_to
        else:
            raise serializers.ValidationError(f"Invalid status: {status}.")

        instance.save()
        return instance


----------------------------------------------------------------------------------------------------------------------------
models.py
from django.db import models
from django.contrib.auth.models import AbstractUser
from django.db import models
from .managers import *

class CustomUser(AbstractUser):
    username = None
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15, blank=True, null=True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    objects = CustomUserManager()

    def __str__(self):
        return self.email


class Orders(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    order_number = models.CharField(max_length=255)
    tracking_number = models.CharField(max_length=255)
    borrowers_first_name = models.CharField(max_length=255)
    borrowers_last_name = models.CharField(max_length=255)
    additional_comments = models.TextField()
    file_url = models.URLField()
    entered_date = models.DateTimeField(null=True, blank=True)
    closing_date = models.DateTimeField(null=True, blank=True)
    disbursment_date = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    zipcode = models.CharField(max_length=10)

class Check(models.Model):
    CHECK_RECEIVED_CHOICES = [
        ('yes', 'Yes'),
        ('no', 'No'),
        ('missing', 'Missing'),
    ]
    order = models.ForeignKey(Orders, on_delete=models.CASCADE,related_name='checks')
    check_received = models.CharField(choices=CHECK_RECEIVED_CHOICES, max_length=10)
    check_received_amount = models.IntegerField(null=True, blank=True)

class Lender(models.Model):
    LENDER_CHOICES = [
        ('affinity', 'Affinity'),
        ('boa', 'Bank of America'),
        ('boa_heloc', 'Bank of America HELOC'),
        # Add other choices
    ]
    order = models.OneToOneField(Orders, on_delete=models.CASCADE)
    lender_type = models.CharField(choices=LENDER_CHOICES, max_length=20)

class State(models.Model):
    STATE_CHOICES = [
        ('jharkhand', 'Jharkhand'),
        ('bihar', 'Bihar'),
        # Add other choices
    ]
    order = models.OneToOneField(Orders, on_delete=models.CASCADE)
    state_type = models.CharField(choices=STATE_CHOICES, max_length=20)

class County(models.Model):
    COUNTY_CHOICES = [
        ('ranchi', 'Ranchi'),
        ('jamshedpur', 'Jamshedpur'),
        # Add other choices
    ]
    state = models.ForeignKey(State, on_delete=models.CASCADE)
    county_type = models.CharField(choices=COUNTY_CHOICES, max_length=20)
--------------------------------------------------------------------------------------------

managers.py
# customuser/managers.py
from django.contrib.auth.models import BaseUserManager

class CustomUserManager(BaseUserManager):
    def create_user(self, email, phone_number=None, password=None, **extra_fields):
        if not email:
            raise ValueError('The Email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, phone_number=phone_number, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        return self.create_user(email, password, **extra_fields)
--------------------------------------------------------------------------------------------------

serializers.py

from rest_framework import serializers
from .models import *

class CustomUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = '__all__'

class CheckListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Check
        fields = '__all__'

        
class OrdersListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Orders
        fields = '__all__'

class CustomUserCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ('email', 'phone_number', 'password')
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        user = CustomUser.objects.create_user(**validated_data)
        return user


class CheckSerializer(serializers.ModelSerializer):
    class Meta:
        model = Check
        fields = ('check_received', 'check_received_amount')

    def validate(self, data):
        check_received = data.get('check_received')
        check_received_amount = data.get('check_received_amount')

        if check_received == 'yes' and not check_received_amount:
            raise serializers.ValidationError("check_received_amount is required when check_received is 'yes'.")

        return data

class OrdersSerializer(serializers.ModelSerializer):
    check = CheckSerializer(many=True)
    user = 1
    class Meta:
        model = Orders
        fields = ('user','order_number', 'tracking_number', 'borrowers_first_name', 'borrowers_last_name', 'additional_comments', 'check')
    
    def create(self, validated_data):
        check_data = validated_data.pop('check',None)
        order_number = validated_data.get('order_number')
        validated_data['user'] = validated_data.get('user')
        existing_order = Orders.objects.filter(order_number=order_number).first()
        if existing_order:
            raise serializers.ValidationError({"order_number": ["Order with this order_number already exists."]})
        
        order = Orders.objects.create(**validated_data)
        if check_data:
            for check_data in check_data:
                Check.objects.create(order=order, **check_data)
        return order

---------------------------------------------------------------------
views.py
from rest_framework import generics
from rest_framework.response import Response
from rest_framework import status
from django.db.models import Prefetch

from .models import *
from .serializers import *

class CustomUserListView(generics.ListAPIView):
    queryset = CustomUser.objects.all()
    serializer_class = CustomUserSerializer

class CustomUserCreateView(generics.CreateAPIView):
    queryset = CustomUser.objects.all()
    serializer_class = CustomUserCreateSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)


class OrdersListView(generics.ListAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersListSerializer

    def get_queryset(self):
        # Customize the queryset to include related Check data
        return Orders.objects.prefetch_related('checks').all()

    def get_check_data(self, order_id):
        # Your logic to get Check data for a specific order
        checks = Check.objects.filter(order_id=order_id).values('check_received', 'check_received_amount')
        checks_list = list(checks)
        return checks_list

    def list(self, request, *args, **kwargs):
        # Override the list method to customize serialized data
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        print(serializer)
        # Customize serialized data to include Check details
        for order_data in serializer.data:
            print(order_data)
            order_id = order_data['id']
            check_data = self.get_check_data(order_id)
            order_data['check'] = check_data

        return Response(serializer.data)

class OrdersCreateView(generics.CreateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersSerializer
---------------------------------------------------------------------------------


urls.py

from django.urls import path
from .views import *

urlpatterns = [
    path('users/', CustomUserListView.as_view(), name='user-list'),
    path('users/create/', CustomUserCreateView.as_view(), name='user-create'),
    path('orders/create/', OrdersCreateView.as_view(), name='create-order'),
    path('orders/list/', OrdersListView.as_view(), name='order-list'),
]



-------------------------------------------------------------------------------------------------------------------------------------------------------------

# serializers.py
from rest_framework import serializers
from .models import Orders, Lender, State, County

class LenderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Lender
        fields = ('lender_type',)

class StateSerializer(serializers.ModelSerializer):
    class Meta:
        model = State
        fields = ('state_type',)

class CountySerializer(serializers.ModelSerializer):
    class Meta:
        model = County
        fields = ('county_type',)

class OrdersPatchSerializer(serializers.ModelSerializer):
    lender = LenderSerializer(required=False)
    state = StateSerializer(required=False)
    county = CountySerializer(required=False)

    class Meta:
        model = Orders
        fields = ('entered_date', 'closing_date', 'disbursment_date', 'lender', 'state', 'county')

    def update(self, instance, validated_data):
        # Update the main Orders model fields
        instance.entered_date = validated_data.get('entered_date', instance.entered_date)
        instance.closing_date = validated_data.get('closing_date', instance.closing_date)
        instance.disbursment_date = validated_data.get('disbursment_date', instance.disbursment_date)
        instance.save()

        # Update the related Lender, State, County models
        lender_data = validated_data.get('lender')
        state_data = validated_data.get('state')
        county_data = validated_data.get('county')

        if lender_data:
            lender, created = Lender.objects.get_or_create(order=instance)
            lender.lender_type = lender_data.get('lender_type')
            lender.save()

        if state_data:
            state, created = State.objects.get_or_create(order=instance)
            state.state_type = state_data.get('state_type')
            state.save()

        if county_data:
            county, created = County.objects.get_or_create(state=state)
            county.county_type = county_data.get('county_type')
            county.save()

        return instance

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
# views.py
from rest_framework import generics
from .models import Orders
from .serializers import OrdersPatchSerializer

class OrdersPatchView(generics.UpdateAPIView):
    queryset = Orders.objects.all()
    serializer_class = OrdersPatchSerializer
    lookup_field = 'order_number'  # Assuming order_number is unique

    def get_object(self):
        order_number = self.kwargs.get(self.lookup_field)
        return self.queryset.get(order_number=order_number)


-------------------------------------------------------------------------------------------------------------
# urls.py
from django.urls import path
from .views import OrdersPatchView

urlpatterns = [
    path('orders/<str:order_number>/', OrdersPatchView.as_view(), name='orders-patch'),
    # Add other URL patterns as needed
]


-->

<html>
  <body>
    <h1> hey </h1>
  </body>
</html>





<!-- 


tests.py

# myapp/tests.py
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from .models import CustomUser, Orders, Employee, Check

class CustomUserTests(TestCase):
    def test_create_user(self):
        response = self.client.post('/api/users/create/', {
            'email': 'test@example.com',
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(CustomUser.objects.count(), 1)
        user = CustomUser.objects.get()
        self.assertEqual(user.email, 'test@example.com')

class OrdersTests(APITestCase):
    def setUp(self):
        # Create a user for testing
        self.user = CustomUser.objects.create(email='test@example.com', password='testpassword')
        # Create an employee for testing
        self.employee = Employee.objects.create(user=self.user, employee_id='123', designation='Test', process='Test', branch='Test', reporting_to=self.user)
        
    def test_create_order(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Orders.objects.count(), 1)
        order = Orders.objects.get()
        self.assertEqual(order.order_number, '123456')

    def test_list_orders(self):
        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)  # Assuming no orders in the test database

    # Add more tests as needed for other APIs


--------------------------------------------------------------------------------------------------------

# myapp/tests.py
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from .models import CustomUser, Orders, Employee, Check

class CustomUserTests(APITestCase):
    def test_create_user(self):
        response = self.client.post('/api/users/create/', {
            'email': 'test@example.com',
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(CustomUser.objects.count(), 1)
        user = CustomUser.objects.get()
        self.assertEqual(user.email, 'test@example.com')

    def test_create_user_invalid_data(self):
        response = self.client.post('/api/users/create/', {
            'email': 'invalidemail',  # Invalid email format
            'phone_number': '1234567890',
            'password': 'testpassword'
        })

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(CustomUser.objects.count(), 0)

class OrdersTests(APITestCase):
    def setUp(self):
        self.user = CustomUser.objects.create(email='test@example.com', password='testpassword')
        self.employee = Employee.objects.create(user=self.user, employee_id='123', designation='Test', process='Test', branch='Test', reporting_to=self.user)
        
    def test_create_order(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Orders.objects.count(), 1)
        order = Orders.objects.get()
        self.assertEqual(order.order_number, '123456')

    def test_create_order_invalid_data(self):
        self.client.force_authenticate(self.user)
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': 'invalid_order',  # Invalid order_number format
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(Orders.objects.count(), 0)

    def test_list_orders(self):
        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)  # Assuming no orders in the test database

    # Add more tests as needed for other APIs
------------------------------------------------------------------------------------------------------------------------------
# myapp/tests.py
# ...

class OrdersTests(APITestCase):
    # ... (previous test cases)

    def test_create_order_unauthenticated(self):
        # Ensure creating an order without authentication returns 401 Unauthorized
        response = self.client.post('/api/orders/create/', {
            'employee': self.employee.id,
            'order_number': '123456',
            'tracking_number': '789012',
            'borrowers_first_name': 'John',
            'borrowers_last_name': 'Doe',
            'additional_comments': 'Some additional comments',
            'check': [
                {'check_received': 'yes', 'check_received_amount': 500},
                {'check_received': 'yes', 'check_received_amount': 600}
            ]
        })

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(Orders.objects.count(), 0)

    def test_list_orders_with_checks(self):
        # Ensure listing orders also includes check details
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        Check.objects.create(order=order, check_received='yes', check_received_amount=500)
        Check.objects.create(order=order, check_received='yes', check_received_amount=600)

        self.client.force_authenticate(self.user)
        response = self.client.get('/api/orders/list/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(len(response.data[0]['check']), 2)

    def test_patch_order_manifest_pending(self):
        # Ensure patching an order with 'manifest pending' status updates fields
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        self.client.force_authenticate(self.user)
        response = self.client.patch(f'/api/orders/{order.order_number}/', {
            'status': 'manifest pending',
            'entered_date': '2023-01-01',
            'closing_date': '2023-02-01',
            'disbursment_date': '2023-03-01',
            'loan_number': 12345,
            'lender': 'Test Lender',
            'state': 'California',
            'county': 'Los Angeles',
            'zipcode': '90001'
        })

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        updated_order = Orders.objects.get(pk=order.pk)
        self.assertEqual(updated_order.entered_date, '2023-01-01')
        self.assertEqual(updated_order.closing_date, '2023-02-01')
        self.assertEqual(updated_order.disbursment_date, '2023-03-01')
        self.assertEqual(updated_order.loan_number, 12345)
        self.assertEqual(updated_order.lender, 'Test Lender')
        self.assertEqual(updated_order.state, 'California')
        self.assertEqual(updated_order.county, 'Los Angeles')
        self.assertEqual(updated_order.zipcode, '90001')

    def test_patch_order_not_assigned(self):
        # Ensure patching an order with 'not yet assigned' status updates 'assigned_to'
        order = Orders.objects.create(
            employee=self.employee,
            order_number='123456',
            tracking_number='789012',
            borrowers_first_name='John',
            borrowers_last_name='Doe',
            additional_comments='Some additional comments'
        )

        self.client.force_authenticate(self.user)
        response = self.client.patch(f'/api/orders/{order.order_number}/', {
            'status': 'not yet assigned',
            'assigned_to': 'new_assignee@example.com'
        })

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        updated_order = Orders.objects.get(pk=order.pk)
        self.assertEqual(updated_order.assigned_to, 'new_assignee@example.com')

    # Add more test cases as needed for other scenarios
----------------------------------------------------------------------------------------------------------------------

python manage.py test myapp.tests

----------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++=============================-----------------------------------------------------------


# project_graphql/schema.py
import graphene
from graphene_django.types import DjangoObjectType
from .models import Order
import requests

class OrderType(DjangoObjectType):
    class Meta:
        model = Order

class Query(graphene.ObjectType):
    all_orders = graphene.List(OrderType)

    def resolve_all_orders(self, info):
        return Order.objects.all()

class FetchAndSaveOrdersMutation(graphene.Mutation):
    class Arguments:
        api_url = graphene.String(required=True)
        params = graphene.JSONString(required=True)  # JSON string representing parameters to send to the API

    success = graphene.Boolean()

    def mutate(self, info, api_url, params):
        try:
            # Make a request to the specified API URL with the provided parameters
            response = requests.get(api_url, params=params)
            response.raise_for_status()  # Raise an error for HTTP errors

            # Parse the JSON response assuming it is in the expected format
            data = response.json()

            # Update the Order model based on the fetched data
            for order_data in data:
                Order.objects.create(
                    order_id=order_data.get('order_id'),
                    tracking_number=order_data.get('tracking_number'),
                    borrowers_first_name=order_data.get('borrowers_first_name'),
                    borrowers_last_name=order_data.get('borrowers_last_name'),
                    additional_comments=order_data.get('additional_comments'),
                    # Add other fields as needed
                )

            success = True  # Set to True if the operation is successful
        except Exception as e:
            print(f"Error fetching and saving Orders: {str(e)}")
            success = False

        return FetchAndSaveOrdersMutation(success=success)

class Mutation(graphene.ObjectType):
    fetch_and_save_orders = FetchAndSaveOrdersMutation.Field()

schema = graphene.Schema(query=Query, mutation=Mutation)


----------------------------------------------------------------------------------------------------------------------------------------
mutation {
  fetch_and_save_orders(api_url: "http://example.com/api/orders", params: "{\"status\": \"shipped\", \"limit\": 10}") {
    success
  }
}
-------------------------------------------------------------------------------------------------

mutation {
  fetch_and_save_orders(api_url: "http://example.com/api/orders", ids: [1, 2, 3]) {
    success
  }
}
------------------------##############################################################################---------------------------------------------------------------------

// EditOrder.js
import React, { useState } from 'react';
import { useMutation } from '@apollo/client';
import gql from 'graphql-tag';

const EDIT_ORDER = gql`
  mutation EditOrder($api_url: String!, $params: String!) {
    fetch_and_save_orders(api_url: $api_url, params: $params) {
      success
    }
  }
`;

const EditOrder = ({ orderId, currentAmount }) => {
  const [newAmount, setNewAmount] = useState(currentAmount);

  const [editOrder] = useMutation(EDIT_ORDER);

  const handleEdit = () => {
    // Prepare the parameters for the API request
    const params = JSON.stringify({
      id: orderId,
      amount: newAmount,
      // Add other parameters as needed
    });

    // Define the API URL
    const apiUrl = 'http://example.com/api/edit_order';

    // Make the mutation request
    editOrder({
      variables: {
        api_url: apiUrl,
        params: params,
      },
    })
      .then((response) => {
        // Handle the response if needed
        console.log(response);
      })
      .catch((error) => {
        // Handle errors
        console.error(error);
      });
  };

  return (
    <div>
      <label htmlFor="newAmount">New Amount:</label>
      <input
        type="number"
        id="newAmount"
        value={newAmount}
        onChange={(e) => setNewAmount(e.target.value)}
      />
      <button onClick={handleEdit}>Edit Order</button>
    </div>
  );
};

export default EditOrder;
-----------------------------------------------------------------#################################################################-------------------------------------------

// App.js
import React from 'react';
import { ApolloProvider, ApolloClient, InMemoryCache } from '@apollo/client';
import EditOrder from './EditOrder';

// Define your GraphQL endpoint
const uri = 'http://localhost:8000/graphql/';

const client = new ApolloClient({
  uri,
  cache: new InMemoryCache(),
});

const orders = [
  // Sample order data
  { id: 1, amount: 100 },
  { id: 2, amount: 150 },
  // Add more orders as needed
];

const App = () => {
  return (
    <ApolloProvider client={client}>
      <div>
        {orders.map((order) => (
          <div key={order.id}>
            <p>Order ID: {order.id}</p>
            <p>Amount: {order.amount}</p>
            <EditOrder orderId={order.id} currentAmount={order.amount} />
            <hr />
          </div>
        ))}
      </div>
    </ApolloProvider>
  );
};

export default App;






-->
